"""
Iterative Month-Ahead Forecasting Script
Performs walk-forward forecasts for Jan-Dec 2025 using multiple models
"""

# ============================================================================
# INSTALLATION COMMANDS
# ============================================================================
# Run these commands first if packages are not installed:
# !pip install pandas numpy scikit-learn statsmodels sktime pmdarima timesfm
# !pip install --upgrade numpy  # Ensure compatible numpy version

# ============================================================================
# IMPORTS
# ============================================================================
import pandas as pd
import numpy as np
import warnings
from datetime import datetime, timedelta
from dateutil.relativedelta import relativedelta
from concurrent.futures import ProcessPoolExecutor, ThreadPoolExecutor, as_completed
from functools import partial
import multiprocessing as mp
from typing import Dict, List, Tuple
import time

# Forecasting models
from sktime.forecasting.naive import NaiveForecaster
from sktime.forecasting.croston import Croston
from sktime.forecasting.base import ForecastingHorizon
from pmdarima import auto_arima
from sklearn.metrics import mean_absolute_error, mean_squared_error

# TimeFM (assuming installed)
try:
    import timesfm
    TIMESFM_AVAILABLE = True
except ImportError:
    TIMESFM_AVAILABLE = False
    print("Warning: TimeFM not available. Install with: pip install timesfm")

warnings.filterwarnings('ignore')

# Get number of CPU cores for parallel processing
N_CORES = max(1, mp.cpu_count() - 1)  # Leave one core free
print(f"Using {N_CORES} CPU cores for parallel processing")

# ============================================================================
# SYNTHETIC DATA GENERATION
# ============================================================================
def generate_synthetic_data():
    """
    Generate synthetic monthly data from 2022-01 to 2025-12
    with two status types: 'open' and 'closed'
    """
    # Date range: 2022-01 to 2025-12 (48 months)
    dates = pd.date_range(start='2022-01-31', end='2025-12-31', freq='ME')
    
    np.random.seed(42)
    data = []
    
    for status in ['open', 'closed']:
        # Create different patterns for each status
        if status == 'open':
            # Trend + seasonality + noise
            trend = np.linspace(100, 150, len(dates))
            seasonality = 20 * np.sin(np.arange(len(dates)) * 2 * np.pi / 12)
            noise = np.random.normal(0, 5, len(dates))
            values = trend + seasonality + noise
        else:
            # Different pattern for closed status
            trend = np.linspace(80, 120, len(dates))
            seasonality = 15 * np.cos(np.arange(len(dates)) * 2 * np.pi / 12)
            noise = np.random.normal(0, 4, len(dates))
            values = trend + seasonality + noise
        
        for date, value in zip(dates, values):
            data.append({
                'date': date,
                'value': max(0, value),  # Ensure non-negative
                'status': status
            })
    
    df = pd.DataFrame(data)
    df = df.sort_values(['date', 'status']).reset_index(drop=True)
    return df

# ============================================================================
# HELPER CLASSES
# ============================================================================
class GrandMeanForecaster:
    """Simple forecaster that predicts the grand mean of all historical data"""
    
    def __init__(self):
        self.mean_ = None
    
    def fit(self, y):
        self.mean_ = np.mean(y)
        return self
    
    def predict(self, fh):
        if isinstance(fh, int):
            return np.repeat(self.mean_, fh)
        return np.repeat(self.mean_, len(fh))

class TimeFMWrapper:
    """Wrapper for TimeFM model"""
    
    def __init__(self):
        if TIMESFM_AVAILABLE:
            self.model = timesfm.TimesFm(
                context_len=128,
                horizon_len=1,
                input_patch_len=32,
                output_patch_len=128,
                num_layers=20,
                model_dims=1280
            )
        else:
            self.model = None
    
    def fit(self, y):
        # TimeFM is pre-trained, no fitting needed
        return self
    
    def predict(self, y_hist, fh=1):
        if self.model is None:
            return np.array([np.mean(y_hist)])
        
        # Prepare input data
        input_data = np.array(y_hist).reshape(1, -1)
        
        try:
            forecast = self.model.forecast(
                inputs=input_data,
                freq='M'
            )
            return forecast[0][:fh]
        except:
            # Fallback to mean if TimeFM fails
            return np.array([np.mean(y_hist)])

# ============================================================================
# FORECASTING FUNCTIONS
# ============================================================================
def forecast_with_naive(y_train, fh):
    """Forecast using NaiveForecaster (last value)"""
    model = NaiveForecaster(strategy="last")
    model.fit(y_train)
    return model.predict(fh)

def forecast_with_croston(y_train, fh):
    """Forecast using Croston's method"""
    try:
        model = Croston()
        model.fit(y_train)
        return model.predict(fh)
    except:
        # Fallback to naive if Croston fails
        return forecast_with_naive(y_train, fh)

def forecast_with_grandmean(y_train, fh):
    """Forecast using grand mean"""
    model = GrandMeanForecaster()
    model.fit(y_train.values)
    return model.predict(fh)

def forecast_with_autoarima(y_train, fh):
    """Forecast using AutoARIMA"""
    try:
        model = auto_arima(
            y_train, 
            seasonal=True, 
            m=12,
            suppress_warnings=True,
            stepwise=True,
            max_p=3,
            max_q=3,
            max_P=2,
            max_Q=2,
            max_order=5,
            trace=False
        )
        forecast = model.predict(n_periods=fh if isinstance(fh, int) else len(fh))
        return forecast
    except:
        # Fallback to naive if AutoARIMA fails
        return forecast_with_naive(y_train, fh)

def forecast_with_timesfm(y_train, fh):
    """Forecast using TimeFM"""
    if not TIMESFM_AVAILABLE:
        return forecast_with_naive(y_train, fh)
    
    try:
        model = TimeFMWrapper()
        model.fit(y_train.values)
        return model.predict(y_train.values, fh=fh if isinstance(fh, int) else len(fh))
    except:
        return forecast_with_naive(y_train, fh)

# ============================================================================
# MAIN FORECASTING LOOP
# ============================================================================
def run_iterative_forecasts(df):
    """
    Perform iterative month-ahead forecasts for Jan-Dec 2025
    """
    forecast_results = []
    
    # Define forecast months
    forecast_months = pd.date_range(start='2025-01-31', end='2025-12-31', freq='ME')
    
    # Define models
    models = {
        'NaiveForecaster': forecast_with_naive,
        'Croston': forecast_with_croston,
        'GrandMeanForecaster': forecast_with_grandmean,
        'AutoARIMA': forecast_with_autoarima,
        'TimeFM': forecast_with_timesfm
    }
    
    print("=" * 80)
    print("ITERATIVE FORECASTING IN PROGRESS")
    print("=" * 80)
    
    # Iterate through each forecast month
    for forecast_date in forecast_months:
        print(f"\nForecasting for: {forecast_date.strftime('%Y-%m')}")
        
        # Iterate through each status
        for status in ['open', 'closed']:
            # Filter data for current status
            status_data = df[df['status'] == status].copy()
            status_data = status_data.sort_values('date')
            
            # Get training data (all data up to prior month)
            train_data = status_data[status_data['date'] < forecast_date]
            
            if len(train_data) == 0:
                continue
            
            # Prepare time series
            y_train = pd.Series(
                train_data['value'].values,
                index=pd.DatetimeIndex(train_data['date'])
            )
            
            # Forecast with each model
            for model_name, forecast_func in models.items():
                try:
                    # Generate forecast
                    fh = ForecastingHorizon([1], is_relative=True)
                    
                    if model_name in ['AutoARIMA', 'TimeFM']:
                        prediction = forecast_func(y_train, fh=1)
                        if isinstance(prediction, np.ndarray):
                            predicted_value = prediction[0]
                        else:
                            predicted_value = float(prediction)
                    else:
                        prediction = forecast_func(y_train, fh)
                        predicted_value = float(prediction.iloc[0])
                    
                    # Store result
                    forecast_results.append({
                        'forecast_date': forecast_date,
                        'status': status,
                        'model': model_name,
                        'predicted_value': predicted_value
                    })
                    
                    print(f"  {status:7s} | {model_name:20s} | {predicted_value:8.2f}")
                    
                except Exception as e:
                    print(f"  {status:7s} | {model_name:20s} | ERROR: {str(e)[:30]}")
    
    return pd.DataFrame(forecast_results)

# ============================================================================
# PERFORMANCE EVALUATION
# ============================================================================
def calculate_performance_metrics(df, forecast_df):
    """
    Calculate MAE, RMSE, and MAPE for each model and status
    """
    performance_results = []
    
    # Get actual 2025 values
    actual_2025 = df[df['date'].dt.year == 2025].copy()
    
    for status in ['open', 'closed']:
        status_actual = actual_2025[actual_2025['status'] == status]
        status_forecasts = forecast_df[forecast_df['status'] == status]
        
        for model in forecast_df['model'].unique():
            model_forecasts = status_forecasts[status_forecasts['model'] == model]
            
            # Merge actual and predicted
            merged = pd.merge(
                status_actual[['date', 'value']],
                model_forecasts[['forecast_date', 'predicted_value']],
                left_on='date',
                right_on='forecast_date',
                how='inner'
            )
            
            if len(merged) == 0:
                continue
            
            actual_values = merged['value'].values
            predicted_values = merged['predicted_value'].values
            
            # Calculate metrics
            mae = mean_absolute_error(actual_values, predicted_values)
            rmse = np.sqrt(mean_squared_error(actual_values, predicted_values))
            mape = np.mean(np.abs((actual_values - predicted_values) / actual_values)) * 100
            
            performance_results.append({
                'status': status,
                'model': model,
                'MAE': mae,
                'RMSE': rmse,
                'MAPE (%)': mape
            })
    
    return pd.DataFrame(performance_results)

# ============================================================================
# MAIN EXECUTION
# ============================================================================
if __name__ == "__main__":
    print("\n" + "=" * 80)
    print("ITERATIVE MONTH-AHEAD FORECASTING SYSTEM")
    print("=" * 80)
    
    # Generate synthetic data
    print("\n1. Generating synthetic dataset...")
    df = generate_synthetic_data()
    print(f"   Dataset shape: {df.shape}")
    print(f"   Date range: {df['date'].min()} to {df['date'].max()}")
    print(f"   Status types: {df['status'].unique().tolist()}")
    
    # Run iterative forecasts
    print("\n2. Running iterative forecasts for Jan-Dec 2025...")
    forecast_df = run_iterative_forecasts(df)
    
    # Calculate performance metrics
    print("\n3. Calculating performance metrics...")
    performance_df = calculate_performance_metrics(df, forecast_df)
    
    # Display results
    print("\n" + "=" * 80)
    print("FORECAST RESULTS")
    print("=" * 80)
    print(forecast_df.to_string(index=False))
    
    print("\n" + "=" * 80)
    print("MODEL PERFORMANCE METRICS (2025)")
    print("=" * 80)
    print(performance_df.to_string(index=False))
    
    print("\n" + "=" * 80)
    print("EXECUTION COMPLETE")
    print("=" * 80)

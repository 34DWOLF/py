import pandas as pd
import requests
import json
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.linear_model import LogisticRegression
from sklearn.pipeline import Pipeline
import numpy as np
import re
import warnings
warnings.filterwarnings('ignore')

def fetch_mitre_attack_data():
    """
    Fetch MITRE ATT&CK data from GitHub
    """
    print("Fetching MITRE ATT&CK data...")
    
    # MITRE ATT&CK STIX data URL
    url = "https://raw.githubusercontent.com/mitre/cti/master/enterprise-attack/enterprise-attack.json"
    
    try:
        response = requests.get(url)
        response.raise_for_status()
        data = response.json()
        
        # Extract threat actors (intrusion-sets)
        threat_actors = []
        for obj in data['objects']:
            if obj['type'] == 'intrusion-set':
                actor_info = {
                    'Name': obj.get('name', ''),
                    'Description': obj.get('description', ''),
                    'Aliases': obj.get('aliases', []),
                    'Created': obj.get('created', ''),
                    'Modified': obj.get('modified', '')
                }
                threat_actors.append(actor_info)
        
        mitre_df = pd.DataFrame(threat_actors)
        print(f"Successfully fetched {len(mitre_df)} threat actors from MITRE ATT&CK")
        return mitre_df
    
    except Exception as e:
        print(f"Error fetching MITRE data: {e}")
        return pd.DataFrame()

def create_ml_classifier(df_train):
    """
    Create and train a lightweight ML classifier for nation state extraction
    """
    print("\nCreating ML classifier...")
    
    # Filter out empty entries
    df_train = df_train[df_train['Description'].notna() & df_train['Suspect'].notna()]
    df_train = df_train[df_train['Suspect'].str.strip() != '']
    
    if len(df_train) == 0:
        raise ValueError("No valid training data found. Please ensure df_train contains valid data.")
    
    print(f"Training with {len(df_train)} examples...")
    
    # Create pipeline with TF-IDF and Logistic Regression
    pipeline = Pipeline([
        ('tfidf', TfidfVectorizer(
            max_features=1000,
            ngram_range=(1, 3),
            stop_words='english',
            lowercase=True
        )),
        ('classifier', LogisticRegression(
            max_iter=1000,
            random_state=42,
            C=1.0
        ))
    ])
    
    # Prepare training data
    X_train = df_train['Description'].values
    y_train = df_train['Suspect'].values
    
    # Train the model
    print("Training classifier...")
    pipeline.fit(X_train, y_train)
    
    # Get unique classes for reference
    classes = pipeline.named_steps['classifier'].classes_
    print(f"Trained on {len(classes)} unique nation states")
    
    return pipeline

def extract_nation_states_with_ml(mitre_df, classifier):
    """
    Extract nation states from MITRE descriptions using ML classifier
    """
    print("\nExtracting nation states from MITRE descriptions...")
    
    # Create a copy to store results
    result_df = mitre_df.copy()
    result_df['primary_nation_state'] = ''
    result_df['match_source'] = ''
    result_df['confidence'] = 0.0
    
    extracted_count = 0
    
    for idx, row in result_df.iterrows():
        # Combine name, description and aliases for context
        name = row['Name']
        description = row['Description']
        aliases = row['Aliases']
        
        # Create text for analysis
        text_parts = []
        if description:  # Primary focus on description
            text_parts.append(str(description))
        if name:
            text_parts.append(str(name))
        if isinstance(aliases, list) and aliases:
            text_parts.extend([str(alias) for alias in aliases])
        
        combined_text = ' '.join(text_parts)
        
        if not combined_text.strip():
            continue
        
        try:
            # Get prediction and probability
            prediction = classifier.predict([combined_text])[0]
            probabilities = classifier.predict_proba([combined_text])[0]
            max_prob = probabilities.max()
            
            # Only accept predictions with reasonable confidence
            if max_prob > 0.3:  # Threshold can be adjusted
                result_df.at[idx, 'primary_nation_state'] = prediction
                result_df.at[idx, 'match_source'] = 'ml_extraction'
                result_df.at[idx, 'confidence'] = max_prob
                extracted_count += 1
        except Exception as e:
            # Skip if prediction fails
            continue
    
    print(f"Extracted nation states for {extracted_count} entries using ML classifier")
    return result_df

def match_threat_actors(result_df, raw_df):
    """
    Match MITRE threat actors with raw_df based on threat actor names
    Only processes entries that don't already have a nation state
    """
    print("\nMatching remaining threat actors with raw_df...")
    
    # Normalize names for better matching
    def normalize_name(name):
        if pd.isna(name):
            return ''
        # Remove special characters and extra spaces
        name = str(name).strip().lower()
        name = re.sub(r'[^\w\s-]', '', name)
        return name
    
    # Create normalized columns for matching
    result_df['name_normalized'] = result_df['Name'].apply(normalize_name)
    raw_df['threat_actor_normalized'] = raw_df['Threat actor name'].apply(normalize_name)
    
    # Only process entries without nation states
    no_nation_mask = result_df['primary_nation_state'] == ''
    matched_count = 0
    
    for idx in result_df[no_nation_mask].index:
        mitre_name = result_df.at[idx, 'name_normalized']
        
        # Check direct match
        match = raw_df[raw_df['threat_actor_normalized'] == mitre_name]
        if not match.empty:
            nation = match.iloc[0]['primary_nation_state']
            if pd.notna(nation) and nation.strip():
                result_df.at[idx, 'primary_nation_state'] = nation
                result_df.at[idx, 'match_source'] = 'threat_actors_exact'
                result_df.at[idx, 'confidence'] = 1.0
                matched_count += 1
                continue
        
        # Check if MITRE name is in raw_df threat actor name (partial match)
        for _, raw_row in raw_df.iterrows():
            if mitre_name and (mitre_name in raw_row['threat_actor_normalized'] or \
               raw_row['threat_actor_normalized'] in mitre_name):
                nation = raw_row['primary_nation_state']
                if pd.notna(nation) and nation.strip():
                    result_df.at[idx, 'primary_nation_state'] = nation
                    result_df.at[idx, 'match_source'] = 'threat_actors_partial'
                    result_df.at[idx, 'confidence'] = 0.8
                    matched_count += 1
                    break
        
        # Check aliases
        if result_df.at[idx, 'primary_nation_state'] == '':
            aliases = result_df.at[idx, 'Aliases']
            if isinstance(aliases, list):
                for alias in aliases:
                    alias_normalized = normalize_name(alias)
                    match = raw_df[raw_df['threat_actor_normalized'] == alias_normalized]
                    if not match.empty:
                        nation = match.iloc[0]['primary_nation_state']
                        if pd.notna(nation) and nation.strip():
                            result_df.at[idx, 'primary_nation_state'] = nation
                            result_df.at[idx, 'match_source'] = 'threat_actors_alias'
                            result_df.at[idx, 'confidence'] = 0.9
                            matched_count += 1
                            break
    
    # Clean up temporary columns
    result_df = result_df.drop(['name_normalized'], axis=1)
    
    print(f"Matched {matched_count} additional threat actors from raw_df")
    
    return result_df

def main(raw_df, df_train):
    """
    Main function to orchestrate the entire process
    Requires df_train with columns: 'Description' and 'Suspect'
    """
    print("Starting MITRE ATT&CK threat actor matching process...")
    
    # Step 1: Fetch MITRE ATT&CK data
    mitre_df = fetch_mitre_attack_data()
    if mitre_df.empty:
        print("Failed to fetch MITRE data. Exiting.")
        return pd.DataFrame()
    
    # Step 2: Train ML classifier with provided training data
    try:
        classifier = create_ml_classifier(df_train)
    except ValueError as e:
        print(f"Error: {e}")
        return pd.DataFrame()
    
    # Step 3: Extract nation states from MITRE descriptions using ML
    result_df = extract_nation_states_with_ml(mitre_df, classifier)
    
    # Step 4: Match remaining actors with raw_df
    final_df = match_threat_actors(result_df, raw_df)
    
    # Summary statistics
    print("\n=== Summary ===")
    print(f"Total threat actors: {len(final_df)}")
    print(f"Matched nation states: {(final_df['primary_nation_state'] != '').sum()}")
    print(f"Blank nation states: {(final_df['primary_nation_state'] == '').sum()}")
    
    # Print breakdown by source
    print("\n=== Match Source Breakdown ===")
    source_counts = final_df['match_source'].value_counts()
    for source, count in source_counts.items():
        if source:
            print(f"{source}: {count}")
    
    # Show confidence statistics for ML predictions
    ml_predictions = final_df[final_df['match_source'] == 'ml_extraction']
    if len(ml_predictions) > 0:
        print(f"\nML Confidence Stats:")
        print(f"  Mean: {ml_predictions['confidence'].mean():.3f}")
        print(f"  Min:  {ml_predictions['confidence'].min():.3f}")
        print(f"  Max:  {ml_predictions['confidence'].max():.3f}")
    
    # Print all results with full details
    print("\n=== Full Results ===")
    # Prepare display dataframe
    display_df = final_df[['Name', 'primary_nation_state', 'match_source', 'Description']].copy()
    display_df['primary_nation_state'] = display_df['primary_nation_state'].fillna('')
    display_df['match_source'] = display_df['match_source'].fillna('')
    
    # Truncate description for display
    display_df['Description'] = display_df['Description'].apply(
        lambda x: (str(x)[:100] + '...') if pd.notna(x) and len(str(x)) > 100 else str(x)
    )
    
    # Set pandas display options for better output
    pd.set_option('display.max_rows', None)
    pd.set_option('display.max_columns', None)
    pd.set_option('display.width', None)
    pd.set_option('display.max_colwidth', None)
    
    print(display_df.to_string(index=False))
    
    # Reset display options
    pd.reset_option('display.max_rows')
    pd.reset_option('display.max_columns')
    pd.reset_option('display.width')
    pd.reset_option('display.max_colwidth')
    
    # Drop confidence column before returning
    final_df = final_df.drop(['confidence'], axis=1)
    
    return final_df

# Execute the MITRE ATT&CK threat actor matching
if __name__ == "__main__":
    # Load training data from SQL
    # df_train = pd.read_sql(
    #     'SELECT "Description", "Suspect" FROM threat_actor_training',
    #     connection
    # )
    
    # For testing, use sample training data
    df_train = pd.DataFrame({
        'Description': [
            'APT28 is a threat group that has been attributed to Russia\'s General Staff Main Intelligence Directorate',
            'Lazarus Group is a North Korean state-sponsored cyber threat group',
            'APT1 is a Chinese cyber espionage group',
            'Indrik Spider is a Russia-based cybercriminal group',
            'Charming Kitten is an Iranian cyber espionage group',
            'Equation Group is tied to US intelligence',
        ],
        'Suspect': [
            'Russia',
            'North Korea',
            'China',
            'Russia',
            'Iran',
            'United States'
        ]
    })
    
    # Run the main function with required training data
    result_df = main(raw_df, df_train)

import pandas as pd
import numpy as np
from statsmodels.tsa.arima.model import ARIMA
import re
import warnings
warnings.filterwarnings('ignore')

def create_composite_gpr(file_path, weights=None):
    """
    Create a composite GPR rating using the Dario Caldara and Matteo Iacoviello Geopolitical Risk data.
    
    Parameters:
    file_path (str): Path to the CSV file containing GPR data
    weights (dict): Dictionary containing weights for each component of the composite score
    
    Returns:
    pandas.DataFrame: DataFrame containing the composite GPR scores
    """
    # Default weights if not provided
    if weights is None:
        weights = {
            'current_gpr': 0.3,
            'historic_gpr': 0.15,
            'global_relative': 0.2,
            'historic_relative': 0.15,
            'forecast': 0.2
        }
    
    # Ensure weights sum to 1
    weight_sum = sum(weights.values())
    if weight_sum != 1.0:
        for key in weights:
            weights[key] = weights[key] / weight_sum
    
    # Read the data
    df = pd.read_csv(file_path)
    print(f"Data loaded with {len(df)} rows")
    
    # Convert month column to datetime
    df['date'] = pd.to_datetime(df['month'])
    
    # Get all country codes from columns
    current_gpr_cols = [col for col in df.columns if col.startswith('GPRC_')]
    historic_gpr_cols = [col for col in df.columns if col.startswith('GPRHC_')]
    
    # Extract country codes
    country_codes = [col.split('_')[1] for col in current_gpr_cols]
    print(f"Found {len(country_codes)} countries")
    
    # Create mapping of country codes to country names using var_name and var_label
    country_names = {}
    
    # Create a mapping of var_name to var_label
    var_name_to_label = {}
    
    # Only do this if var_name and var_label columns exist
    if 'var_name' in df.columns and 'var_label' in df.columns:
        for _, row in df.drop_duplicates('var_name').iterrows():
            if isinstance(row['var_name'], str) and isinstance(row['var_label'], str):
                var_name_to_label[row['var_name']] = row['var_label']
                
                # If this is a current GPR country column, extract the country name
                if row['var_name'].startswith('GPRC_'):
                    country_code = row['var_name'].split('_')[1]
                    country_name_match = re.search(r'\((.*?)\)$', row['var_label'])
                    if country_name_match:
                        country_name = country_name_match.group(1)
                        country_names[country_code] = country_name
    
    # If we couldn't extract country names from var_label, use the country codes
    if not country_names:
        for code in country_codes:
            country_names[code] = code
    
    # Get the most recent 24 months for forecasting purposes
    recent_dates = sorted(df['date'].unique())[-24:]
    recent_df = df[df['date'].isin(recent_dates)]
    
    # Get the latest date with data
    latest_date = recent_df['date'].max()
    latest_df = df[df['date'] == latest_date]
    
    # Initialize result dataframe
    result_columns = ['Date', 'Country', 'Composite GPR', 'Current GPR', 'Historic GPR', 
                      'Average GPR over time', 'Average GPR of the rest of the countries', 'Forecasted GPR']
    result_df = pd.DataFrame(columns=result_columns)
    
    # Process each country
    for i, country_code in enumerate(country_codes):
        print(f"Processing country {i+1}/{len(country_codes)}: {country_code}")
        
        current_gpr_col = f'GPRC_{country_code}'
        historic_gpr_col = f'GPRHC_{country_code}'
        
        # Get current and historic GPR values for the latest date
        if len(latest_df) > 0:
            latest_row = latest_df.iloc[0]
            current_gpr = latest_row[current_gpr_col]
            historic_gpr = latest_row[historic_gpr_col]
        else:
            print(f"No data for the latest date for {country_code}, skipping")
            continue
        
        # Calculate average GPR over time for this country
        avg_gpr_over_time = df[current_gpr_col].mean()
        
        # Calculate average GPR of the rest of the countries for the latest date
        other_countries_cols = [col for col in current_gpr_cols if col != current_gpr_col]
        avg_gpr_rest = latest_row[other_countries_cols].mean()
        
        # Forecast the GPR for next month using ARIMA
        try:
            # Get GPR time series for the last 24 months
            country_gpr_series = recent_df[current_gpr_col].dropna()
            
            if len(country_gpr_series) >= 12:  # Need enough data for forecasting
                model = ARIMA(country_gpr_series, order=(1, 1, 1))
                model_fit = model.fit()
                forecast = model_fit.forecast(steps=1)[0]
            else:
                # Use simple moving average if not enough data
                forecast = country_gpr_series.rolling(window=min(3, len(country_gpr_series))).mean().iloc[-1]
        except Exception as e:
            print(f"Forecasting error for {country_code}: {e}")
            # Fallback to last value if forecasting fails
            forecast = current_gpr
        
        # Find min and max across all countries for normalization
        all_gpr_values = []
        for col in current_gpr_cols + historic_gpr_cols:
            all_gpr_values.extend(df[col].dropna().tolist())
        
        global_min = min(all_gpr_values)
        global_max = max(all_gpr_values)
        
        # Normalize function (min-max scaling to 1-10)
        def normalize(value, min_val, max_val):
            if pd.isna(value) or pd.isna(min_val) or pd.isna(max_val) or max_val == min_val:
                return 5.0  # Default to middle value if unable to normalize
            return 1 + 9 * (value - min_val) / (max_val - min_val)
        
        # Normalize all components
        norm_current_gpr = normalize(current_gpr, global_min, global_max)
        norm_historic_gpr = normalize(historic_gpr, global_min, global_max)
        
        # For global relative, higher values mean higher risk compared to others
        current_gpr_values = [latest_row[col] for col in current_gpr_cols]
        global_min_current = min(current_gpr_values)
        global_max_current = max(current_gpr_values)
        global_relative = normalize(current_gpr, global_min_current, global_max_current)
                                   
        # For historic relative, higher values mean higher risk compared to country's history
        country_min = df[current_gpr_col].min()
        country_max = df[current_gpr_col].max()
        historic_relative = normalize(current_gpr, country_min, country_max)
                                     
        # Normalize forecast
        norm_forecast = normalize(forecast, global_min, global_max)
        
        # Calculate composite score using weights
        composite_score = (
            weights['current_gpr'] * norm_current_gpr +
            weights['historic_gpr'] * norm_historic_gpr +
            weights['global_relative'] * global_relative +
            weights['historic_relative'] * historic_relative +
            weights['forecast'] * norm_forecast
        )
        
        # Add to result dataframe
        new_row = {
            'Date': latest_date,
            'Country': country_names.get(country_code, country_code),
            'Composite GPR': round(composite_score, 2),
            'Current GPR': round(norm_current_gpr, 2),
            'Historic GPR': round(norm_historic_gpr, 2),
            'Average GPR over time': round(normalize(avg_gpr_over_time, global_min, global_max), 2),
            'Average GPR of the rest of the countries': round(normalize(avg_gpr_rest, global_min, global_max), 2),
            'Forecasted GPR': round(norm_forecast, 2)
        }
        result_df = pd.concat([result_df, pd.DataFrame([new_row])], ignore_index=True)
    
    # Sort by Composite GPR (descending)
    result_df = result_df.sort_values('Composite GPR', ascending=False)
    
    return result_df

def main():
    # File path to the GPR data
    file_path = ''
    
    # Define weights (can be adjusted by user)
    weights = {
        'current_gpr': 0.3,       # Weight for current GPR
        'historic_gpr': 0.15,     # Weight for historic GPR
        'global_relative': 0.2,   # Weight for GPR relative to rest of world
        'historic_relative': 0.15, # Weight for GPR relative to country's history
        'forecast': 0.2           # Weight for forecasted GPR
    }
    
    # Create composite GPR
    result_df = create_composite_gpr(file_path, weights)
    
    # Display results
    print(f"Composite GPR Ratings (weights: {weights})")
    print(f"Total countries analyzed: {len(result_df)}")
    display(result_df)
    
    # Return the result dataframe (though it's not saved as per requirements)
    return result_df

if __name__ == "__main__":
    main()

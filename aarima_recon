import pandas as pd
import numpy as np
from sklearn.metrics import mean_squared_error
from math import sqrt
import warnings

import pmdarima as pm
from hts import HTSRegressor
from hts.utilities.load_data import to_ts

warnings.filterwarnings("ignore")

# -----------------------
# Helper: Fit ARIMA or fallback to SMA
# -----------------------
def fit_forecast(series, horizon, window=3):
    series = pd.Series(series).astype(float)

    # If too few nonzeros, skip ARIMA
    if (series != 0).sum() < 5:
        sma_forecast = np.full(horizon, series.rolling(window, min_periods=1).mean().iloc[-1])
        return sma_forecast, "SMA"

    try:
        model = pm.auto_arima(series, seasonal=False, suppress_warnings=True, error_action="ignore")
        forecast = model.predict(n_periods=horizon)
        return forecast, f"ARIMA{model.order}"
    except Exception:
        sma_forecast = np.full(horizon, series.rolling(window, min_periods=1).mean().iloc[-1])
        return sma_forecast, "SMA"

# -----------------------
# 1. Prepare data
# -----------------------
df['Month'] = pd.to_datetime(df['Month'])
wide_df = df.pivot(index='Month', columns='Category', values='Value').fillna(0)
wide_df['Total'] = wide_df.sum(axis=1)

# Train/test split
train_size = int(len(wide_df) * 0.8)
train, test = wide_df.iloc[:train_size], wide_df.iloc[train_size:]
h = len(test)

# -----------------------
# 2. Baseline A: Aggregate-only ARIMA/SMA
# -----------------------
agg_forecast, agg_method = fit_forecast(train['Total'], h)
rmse_agg = sqrt(mean_squared_error(test['Total'], agg_forecast))

# -----------------------
# 3. Baseline B: Bottom-up ARIMA/SMA
# -----------------------
bu_forecasts = {}
bu_methods = {}
for col in train.drop(columns='Total').columns:
    fc, method = fit_forecast(train[col], h)
    bu_forecasts[col] = fc
    bu_methods[col] = method

bu_df = pd.DataFrame(bu_forecasts, index=test.index)
bu_df['Total'] = bu_df.sum(axis=1)

rmse_bu_total = sqrt(mean_squared_error(test['Total'], bu_df['Total']))

# -----------------------
# 4. Reconciled Forecast: Hierarchical ARIMA
# (HTS only works with ARIMA, so sparse-series fallback not applied here)
# -----------------------
hierarchy = {'Total': list(wide_df.drop(columns='Total').columns)}
ts = to_ts(train)

hts_model = HTSRegressor(
    model='ARIMA',
    revision_method='MinT',   # reconciliation
    n_jobs=1,
    low_memory=True,
    hierarchy=hierarchy
)
hts_model.fit(ts)
hts_forecast = hts_model.predict(h=h)

rmse_hts_total = sqrt(mean_squared_error(test['Total'], hts_forecast['Total']))

# -----------------------
# 5. Results
# -----------------------
print("RMSE on Total Series:")
print(f"Aggregate-only ({agg_method}) : {rmse_agg:.2f}")
print(f"Bottom-up (mixed methods)     : {rmse_bu_total:.2f}")
print(f"Reconciled (ARIMA+MinT)       : {rmse_hts_total:.2f}")

print("\nSample of category methods used:")
print(dict(list(bu_methods.items())[:5]))  # show first 5 categories

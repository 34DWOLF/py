import pandas as pd
import numpy as np
from sklearn.metrics import mean_squared_error
from math import sqrt
import pmdarima as pm
from joblib import Parallel, delayed
import warnings

warnings.filterwarnings("ignore")

# -----------------------
# Helper: Fit ARIMA or SMA fallback
# -----------------------
def fit_forecast(series, horizon, window=3):
    """Try ARIMA, fallback to SMA."""
    series = pd.Series(series).astype(float)

    if (series != 0).sum() < 5:  # too sparse
        sma_forecast = np.full(horizon, series.rolling(window, min_periods=1).mean().iloc[-1])
        return sma_forecast, "SMA", None

    try:
        model = pm.auto_arima(series, seasonal=False, suppress_warnings=True, error_action="ignore")
        forecast = model.predict(n_periods=horizon)
        return forecast, "ARIMA", model.order
    except Exception:
        sma_forecast = np.full(horizon, series.rolling(window, min_periods=1).mean().iloc[-1])
        return sma_forecast, "SMA", None


# -----------------------
# Main Forecast Function
# -----------------------
def forecast_with_reconciliation(df, horizon=6, train_size=0.8, window=3, 
                                 use_backtest_for_future=True, n_jobs=1, freq="MS"):
    """
    Forecast hierarchical time series with ARIMA (SMA fallback) and OLS reconciliation.
    Runs ARIMA fits in parallel and forces future frequency.

    Args:
        df (pd.DataFrame): Input with columns ['Month','Category','Value']
        horizon (int): Forecast horizon (future periods beyond dataset)
        train_size (float): Train/test split ratio
        window (int): SMA window size for fallback
        use_backtest_for_future (bool): If True, pick winner based on Total RMSE
        n_jobs (int): Number of parallel jobs (-1 = all cores)
        freq (str): Frequency string for future forecasts (default = "MS" = month start)

    Returns:
        historical_fc_df (pd.DataFrame): Backtest forecasts (with RMSE eval)
        future_fc_df (pd.DataFrame): Future forecasts
        rmse_scores (pd.Series): RMSE by Approach + Category
        best_approach (str): "Base" or "Reconciled"
    """
    # --- Prep ---
    df['Month'] = pd.to_datetime(df['Month'])
    wide_df = df.pivot(index='Month', columns='Category', values='Value').fillna(0)
    wide_df['Total'] = wide_df.sum(axis=1)

    n_train = int(len(wide_df) * train_size)
    train, test = wide_df.iloc[:n_train], wide_df.iloc[n_train:]
    h_test = len(test)
    test_index = test.index

    categories = train.drop(columns="Total").columns.tolist()
    all_nodes = ["Total"] + categories

    # --- Step 1: Parallel ARIMA/SMA on training ---
    results = Parallel(n_jobs=n_jobs)(
        delayed(fit_forecast)(train[node], max(h_test, horizon), window) 
        for node in all_nodes
    )
    base_forecasts = {node: r[0] for node, r in zip(all_nodes, results)}
    metadata = {node: {"Method": r[1], "Order": r[2]} for node, r in zip(all_nodes, results)}

    # --- Step 2: Reconciliation on training ---
    n_cats = len(categories)
    S = np.vstack([np.ones(n_cats), np.eye(n_cats)])
    P = S @ np.linalg.inv(S.T @ S) @ S.T

    def reconcile_step(y_hat): return P @ y_hat

    reconciled = {node: [] for node in all_nodes}
    for t in range(max(h_test, horizon)):
        y_hat = np.array([base_forecasts["Total"][t]] + [base_forecasts[c][t] for c in categories])
        y_rec = reconcile_step(y_hat)
        for j, node in enumerate(all_nodes):
            reconciled[node].append(y_rec[j])

    # --- Step 3: Historical forecasts ---
    hist_rows = []
    for i, date in enumerate(test_index):
        for node in all_nodes:
            hist_rows.append({
                "Category": node, "Date": date,
                "Forecast": base_forecasts[node][i],
                "Method": metadata[node]["Method"],
                "Order": metadata[node]["Order"],
                "Approach": "Base"
            })
            hist_rows.append({
                "Category": node, "Date": date,
                "Forecast": reconciled[node][i],
                "Method": metadata[node]["Method"],
                "Order": metadata[node]["Order"],
                "Approach": "Reconciled"
            })
    historical_fc_df = pd.DataFrame(hist_rows)

    # --- Step 4: RMSE evaluation ---
    rmse_scores = historical_fc_df.groupby(["Approach", "Category"]).apply(
        lambda g: sqrt(mean_squared_error(test[g.name[1]], g["Forecast"]))
    )

    # --- Step 5: Pick winner (TOTAL only) ---
    if use_backtest_for_future:
        total_rmse = rmse_scores.xs("Total", level="Category")
        best_approach = total_rmse.idxmin()
    else:
        best_approach = "Reconciled"

    # --- Step 6: Future forecasts (forced frequency) ---
    future_index = pd.date_range(start=wide_df.index[-1] + pd.tseries.frequencies.to_offset(freq),
                                 periods=horizon, freq=freq)

    # Parallel fit on full dataset
    results_full = Parallel(n_jobs=n_jobs)(
        delayed(fit_forecast)(wide_df[node], horizon, window) 
        for node in all_nodes
    )
    base_fc = {node: r[0] for node, r in zip(all_nodes, results_full)}
    base_meta = {node: {"Method": r[1], "Order": r[2]} for node, r in zip(all_nodes, results_full)}

    reconciled_future = {node: [] for node in all_nodes}
    for t in range(horizon):
        y_hat = np.array([base_fc["Total"][t]] + [base_fc[c][t] for c in categories])
        y_rec = reconcile_step(y_hat)
        for j, node in enumerate(all_nodes):
            reconciled_future[node].append(y_rec[j])

    future_rows = []
    for i, date in enumerate(future_index):
        for node in all_nodes:
            if best_approach == "Base":
                future_rows.append({
                    "Category": node, "Date": date,
                    "Forecast": base_fc[node][i],
                    "Method": base_meta[node]["Method"],
                    "Order": base_meta[node]["Order"],
                    "Approach": "Base"
                })
            else:
                future_rows.append({
                    "Category": node, "Date": date,
                    "Forecast": reconciled_future[node][i],
                    "Method": base_meta[node]["Method"],
                    "Order": base_meta[node]["Order"],
                    "Approach": "Reconciled"
                })

    future_fc_df = pd.DataFrame(future_rows)

    return historical_fc_df, future_fc_df, rmse_scores, best_approach




# Monthly (default)
hist_fc, fut_fc, rmse, winner = forecast_with_reconciliation(df, horizon=12, n_jobs=-1)

import pandas as pd
import numpy as np
from sklearn.metrics import mean_squared_error
from math import sqrt
import warnings
import pmdarima as pm
from hts import HTSRegressor
from hts.utilities.load_data import to_ts

warnings.filterwarnings("ignore")

# -----------------------
# Helper: Fit ARIMA or fallback to SMA
# -----------------------
def fit_forecast(series, horizon, window=3):
    series = pd.Series(series).astype(float)

    # If too few nonzeros, skip ARIMA
    if (series != 0).sum() < 5:
        sma_forecast = np.full(horizon, series.rolling(window, min_periods=1).mean().iloc[-1])
        return sma_forecast, "SMA", None

    try:
        model = pm.auto_arima(series, seasonal=False, suppress_warnings=True, error_action="ignore")
        forecast = model.predict(n_periods=horizon)
        return forecast, "ARIMA", model.order
    except Exception:
        sma_forecast = np.full(horizon, series.rolling(window, min_periods=1).mean().iloc[-1])
        return sma_forecast, "SMA", None

# -----------------------
# 1. Prepare data
# -----------------------
df['Month'] = pd.to_datetime(df['Month'])
wide_df = df.pivot(index='Month', columns='Category', values='Value').fillna(0)
wide_df['Total'] = wide_df.sum(axis=1)

# Train/test split
train_size = int(len(wide_df) * 0.8)
train, test = wide_df.iloc[:train_size], wide_df.iloc[train_size:]
h = len(test)
forecast_index = test.index  # dates of forecast horizon

# -----------------------
# 2. Aggregate-only forecast
# -----------------------
agg_forecast, agg_method, agg_order = fit_forecast(train['Total'], h)

agg_df = pd.DataFrame({
    "Category": "Total",
    "Date": forecast_index,
    "Forecast": agg_forecast,
    "Method": agg_method,
    "Order": [agg_order] * h,
    "Approach": "Aggregate"
})

# -----------------------
# 3. Bottom-up forecasts
# -----------------------
all_fc_dfs = [agg_df]
for col in train.drop(columns="Total").columns:
    fc, method, order = fit_forecast(train[col], h)
    fc_df = pd.DataFrame({
        "Category": col,
        "Date": forecast_index,
        "Forecast": fc,
        "Method": method,
        "Order": [order] * h,
        "Approach": "Bottom-up"
    })
    all_fc_dfs.append(fc_df)

# -----------------------
# 4. Reconciled forecasts (HTS)
# -----------------------
hierarchy = {"Total": list(wide_df.drop(columns="Total").columns)}
ts = to_ts(train)

hts_model = HTSRegressor(
    model="ARIMA",
    revision_method="MinT",
    n_jobs=1,
    low_memory=True,
    hierarchy=hierarchy
)
hts_model.fit(ts)
hts_forecast = hts_model.predict(h=h)

# Convert reconciled results to same format
for col in hts_forecast.columns:
    fc_df = pd.DataFrame({
        "Category": col,
        "Date": forecast_index,
        "Forecast": hts_forecast[col].values,
        "Method": "ARIMA",
        "Order": [None] * h,   # scikit-hts doesnâ€™t expose per-node orders
        "Approach": "Reconciled"
    })
    all_fc_dfs.append(fc_df)

# -----------------------
# 5. Combine into final tidy df
# -----------------------
forecast_df = pd.concat(all_fc_dfs, ignore_index=True)

# -----------------------
# 6. Optional: RMSE evaluation
# -----------------------
rmse_scores = forecast_df.groupby(["Approach", "Category"]).apply(
    lambda g: sqrt(mean_squared_error(
        test[g.name[1]] if g.name[1] != "Total" else test["Total"],
        g["Forecast"]
    ))
)

print("Sample forecast dataframe:")
print(forecast_df.head())

print("\nRMSE by Approach + Category:")
print(rmse_scores.head(10))

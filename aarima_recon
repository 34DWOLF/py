import pandas as pd
import numpy as np
from sklearn.metrics import mean_squared_error
from math import sqrt
import pmdarima as pm
import warnings

warnings.filterwarnings("ignore")

# -----------------------
# Helper: Fit ARIMA or SMA fallback
# -----------------------
def fit_forecast(series, horizon, window=3):
    series = pd.Series(series).astype(float)

    if (series != 0).sum() < 5:
        sma_forecast = np.full(horizon, series.rolling(window, min_periods=1).mean().iloc[-1])
        return sma_forecast, "SMA", None

    try:
        model = pm.auto_arima(series, seasonal=False, suppress_warnings=True, error_action="ignore")
        forecast = model.predict(n_periods=horizon)
        return forecast, "ARIMA", model.order
    except Exception:
        sma_forecast = np.full(horizon, series.rolling(window, min_periods=1).mean().iloc[-1])
        return sma_forecast, "SMA", None


# -----------------------
# 1. Prepare data
# -----------------------
df['Month'] = pd.to_datetime(df['Month'])
wide_df = df.pivot(index='Month', columns='Category', values='Value').fillna(0)
wide_df['Total'] = wide_df.sum(axis=1)

# Train/test split
train_size = int(len(wide_df) * 0.8)
train, test = wide_df.iloc[:train_size], wide_df.iloc[train_size:]
h = len(test)
forecast_index = test.index

# -----------------------
# 2. Fit ARIMA/SMA per series
# -----------------------
categories = train.drop(columns="Total").columns.tolist()
all_nodes = ["Total"] + categories

base_forecasts = {}
metadata = {}

for node in all_nodes:
    fc, method, order = fit_forecast(train[node], h)
    base_forecasts[node] = fc
    metadata[node] = {"Method": method, "Order": order}

# -----------------------
# 3. Reconciliation (MinT simplified as OLS)
# -----------------------
# Build summing matrix S: Total = sum(categories)
n_cats = len(categories)
S = np.vstack([np.ones(n_cats), np.eye(n_cats)])  # (n_cats+1) x n_cats

# Reconcile for each horizon step
reconciled = []
for t in range(h):
    y_hat = np.array([base_forecasts["Total"][t]] + [base_forecasts[c][t] for c in categories])
    # OLS reconciliation: y_tilde = S (S'S)^-1 S' y_hat
    P = S @ np.linalg.inv(S.T @ S) @ S.T
    y_rec = P @ y_hat
    reconciled.append(y_rec)

reconciled = np.array(reconciled)

# -----------------------
# 4. Build tidy forecast dataframe
# -----------------------
rows = []
for i, date in enumerate(forecast_index):
    # Baseline forecasts
    for node in all_nodes:
        rows.append({
            "Category": node,
            "Date": date,
            "Forecast": base_forecasts[node][i],
            "Method": metadata[node]["Method"],
            "Order": metadata[node]["Order"],
            "Approach": "Base"
        })
    # Reconciled forecasts
    for j, node in enumerate(all_nodes):
        rows.append({
            "Category": node,
            "Date": date,
            "Forecast": reconciled[i, j],
            "Method": metadata[node]["Method"],
            "Order": metadata[node]["Order"],
            "Approach": "Reconciled"
        })

forecast_df = pd.DataFrame(rows)

# -----------------------
# 5. RMSE Evaluation
# -----------------------
rmse_scores = forecast_df.groupby(["Approach", "Category"]).apply(
    lambda g: sqrt(mean_squared_error(
        test[g.name[1]] if g.name[1] != "Total" else test["Total"],
        g["Forecast"]
    ))
)

print("Sample output:")
print(forecast_df.head(10))

print("\nRMSE comparison:")
print(rmse_scores.head(10))

# df uses an explicit date column
df = df.copy()
df["reportingMonth"] = pd.to_datetime(df["Month"])
df = df.sort_values("Month").reset_index(drop=True)

# --- 2) Utility: build an ordered parameter vector that matches model.param_names
def build_param_vector(endog, order, params_dict):
    m = ARIMA(endog, order=order, freq="MS")
    names = m.param_names                      # e.g. ['const','ar.L1','ma.L1','sigma2']
    return [params_dict[name] for name in names], names

# --- 3) Rolling / expanding forecasting without fitting
y = model_data["Value"].copy()                 # start from initial history
last_obs = y.index.max()

# ensure output column exists
if "forecast_mean" not in df.columns:
    df["forecast_mean"] = pd.NA

for i, row in df.iterrows():
    target = row["reportingMonth"]

    # Only fill if predictedValue is null
    if pd.isna(row["predictedValue"]):

        # If target is BEFORE or equal to the end of our current series:
        # produce an in-sample (or 1-step-ahead) prediction at that date.
        # If it's AFTER, produce an out-of-sample forecast and append it to y.
        if target <= y.index.max():
            # in-sample prediction at specific index
            param_vec, _ = build_param_vector(y, order, params_dict)
            fitted = ARIMA(y, order=order, freq="MS").filter(param_vec)
            # steps ahead from start to this position:
            # use get_prediction with index 'target' for aligned mean
            pred = fitted.get_prediction(start=target, end=target)
            df.at[i, "forecast_mean"] = float(pred.predicted_mean.iloc[0])
        else:
            # how many months ahead from the last known point?
            last = y.index.max()
            steps = (target.year - last.year) * 12 + (target.month - last.month)
            if steps <= 0:
                steps = 1  # safety

            param_vec, _ = build_param_vector(y, order, params_dict)
            fitted = ARIMA(y, order=order, freq="MS").filter(param_vec)

            fc = fitted.get_forecast(steps=steps).predicted_mean
            val = float(fc.iloc[-1])

            # write forecast for this row
            df.at[i, "forecast_mean"] = val

            # append this forecast to the series so subsequent rows can build on it
            # (this is what makes the process “expanding” without refitting)
            # fill any skipped months in between by taking the intermediate forecasts too
            new_index = pd.date_range(start=last + pd.offsets.MonthBegin(1),
                                      end=target, freq="MS")
            # if steps > 1, fc contains intermediate months leading to target
            y = pd.concat([y, pd.Series(fc.values, index=new_index)], axis=0)

# --- Result: df now has forecast_mean for blank predictedValue rows
# display/return df
df

import pandas as pd
import numpy as np
from pmdarima.arima import auto_arima
from statsmodels.tsa.stattools import adfuller, kpss
from dateutil.relativedelta import relativedelta
from joblib import Parallel, delayed
import sys

# -------------------
# Helper functions
# -------------------

def check_stationarity(series):
    """Check stationarity with ADF, fallback to KPSS if needed."""
    try:
        adf_result = adfuller(series.dropna(), autolag="AIC")
        return adf_result[1] < 0.05  # stationary if p < 0.05
    except Exception:
        try:
            kpss_result = kpss(series.dropna(), regression="c", nlags="auto")
            return kpss_result[1] > 0.05  # stationary if p > 0.05
        except Exception:
            return None  # Inconclusive

def moving_average_forecast(series, horizon=6, window=3):
    """Simple moving average fallback forecast."""
    if len(series) < window:
        avg = series.mean() if len(series) > 0 else 0
        return np.repeat(avg, horizon), "Average", None, None
    avg = series.rolling(window).mean().iloc[-1]
    return np.repeat(avg, horizon), "Moving Average", None, None

def forecast_one_category(cat, group, forecast_horizon):
    """Forecast for a single category with strong fallbacks + logging."""
    series = group.sort_values("Date").set_index("Date")["Value"]

    # enforce monthly frequency
    series = series.asfreq("MS")

    # Drop NaNs introduced by asfreq
    series = series.dropna()

    # Handle empty series
    if len(series) == 0:
        print(f"Skipping {cat} – no data after resampling", flush=True)
        return pd.DataFrame({
            "Category": [cat] * forecast_horizon,
            "Forecast Date": [pd.NaT] * forecast_horizon,
            "Forecast Value": [np.nan] * forecast_horizon,
            "Forecast Method": ["No Data"] * forecast_horizon,
            "ARIMA Order": [None] * forecast_horizon,
            "Seasonal Order": [None] * forecast_horizon
        })

    method_used = None
    order, seasonal_order = None, None

    # If too few points, bail out early with simple average
    if len(series) < 6:
        avg = series.mean() if len(series) > 0 else 0
        forecast = np.repeat(avg, forecast_horizon)
        method_used = "Average"
        print(f"{cat}: Not enough data ({len(series)} points) → using Average", flush=True)
    else:
        stationary = check_stationarity(series)

        try:
            if stationary is None:
                model = auto_arima(series, d=1, seasonal=True, m=12,
                                   error_action="ignore", suppress_warnings=True)
            else:
                model = auto_arima(series, seasonal=True, m=12,
                                   test="adf" if stationary else "kpss",
                                   error_action="ignore", suppress_warnings=True)

            forecast = model.predict(n_periods=forecast_horizon)

            if np.any(np.isnan(forecast)):
                forecast, method_used, order, seasonal_order = moving_average_forecast(series, forecast_horizon)
                print(f"{cat}: ARIMA returned NaN → fallback to {method_used}", flush=True)
            else:
                method_used = "ARIMA"
                order = model.order
                seasonal_order = model.seasonal_order
                print(f"{cat}: Using ARIMA {order} seasonal={seasonal_order}", flush=True)

        except Exception as e:
            forecast, method_used, order, seasonal_order = moving_average_forecast(series, forecast_horizon)
            print(f"{cat}: ARIMA failed ({e}) → fallback to {method_used}", flush=True)

    forecast_dates = [series.index[-1] + relativedelta(months=i+1)
                      for i in range(forecast_horizon)]

    return pd.DataFrame({
        "Category": cat,
        "Forecast Date": forecast_dates,
        "Forecast Value": forecast,
        "Forecast Method": method_used,
        "ARIMA Order": [order] * forecast_horizon,
        "Seasonal Order": [seasonal_order] * forecast_horizon
    })

def robust_auto_forecast_parallel(df, forecast_horizon=6, n_jobs=-1):
    """Run robust AutoARIMA across categories in parallel."""
    df["Date"] = pd.to_datetime(df["Date"])
    groups = [(cat, group) for cat, group in df.groupby("Category")]

    results = Parallel(n_jobs=n_jobs)(
        delayed(forecast_one_category)(cat, group, forecast_horizon)
        for cat, group in groups
    )

    return pd.concat(results, ignore_index=True)

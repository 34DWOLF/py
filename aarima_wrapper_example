import pandas as pd
import numpy as np
from pmdarima.arima import auto_arima
from statsmodels.tsa.stattools import adfuller, kpss
from dateutil.relativedelta import relativedelta

# -------------------
# Helper functions
# -------------------

def check_stationarity(series):
    """Check stationarity with ADF, fallback to KPSS if needed."""
    try:
        adf_result = adfuller(series.dropna(), autolag="AIC")
        return adf_result[1] < 0.05  # stationary if p < 0.05
    except Exception:
        try:
            kpss_result = kpss(series.dropna(), regression="c", nlags="auto")
            return kpss_result[1] > 0.05  # stationary if p > 0.05
        except Exception:
            return None  # Inconclusive

def moving_average_forecast(series, horizon=6, window=3):
    """Simple moving average fallback forecast."""
    avg = series.rolling(window).mean().iloc[-1]
    return np.repeat(avg, horizon)

def robust_auto_forecast(df, forecast_horizon=6):
    """Run robust AutoARIMA across each Category."""
    results = []
    df["Date"] = pd.to_datetime(df["Date"])

    for cat, group in df.groupby("Category"):
        series = group.sort_values("Date").set_index("Date")["Value"]

        # enforce monthly frequency (adjust to 'D' if daily data)
        series = series.asfreq("MS")

        # Step 1: Check stationarity
        stationary = check_stationarity(series)

        # Step 2: Try AutoARIMA with appropriate settings
        try:
            if stationary is None:
                # Inconclusive → force d=1
                model = auto_arima(series, d=1, seasonal=True, m=12,
                                   error_action="ignore", suppress_warnings=True)
            else:
                # Use adf or kpss depending on stationarity outcome
                model = auto_arima(series, seasonal=True, m=12,
                                   test="adf" if stationary else "kpss",
                                   error_action="ignore", suppress_warnings=True)

            forecast = model.predict(n_periods=forecast_horizon)

        except Exception:
            # Step 3: Fallback → Moving average
            forecast = moving_average_forecast(series, forecast_horizon)

        # Step 4: Build forecast horizon dates
        forecast_months = [series.index[-1] + relativedelta(months=i+1)
                           for i in range(forecast_horizon)]

        forecast_df = pd.DataFrame({
            "Category": cat,
            "Forecast Date": forecast_months,
            "Forecast Value": forecast
        })
        results.append(forecast_df)

    return pd.concat(results, ignore_index=True)

# -------------------
# Example usage
# -------------------
# Example df:
# df = pd.DataFrame({
#     "Date": ["2022-01-01","2022-02-01","2022-03-01",
#              "2022-01-01","2022-02-01","2022-03-01"],
#     "Category": ["A","A","A","B","B","B"],
#     "Value": [100, 120, 130, 50, 55, 65]
# })

# Run forecast
# forecast_df = robust_auto_forecast(df, forecast_horizon=6)
# print(forecast_df)










# Parallelized 
import pandas as pd
import numpy as np
from pmdarima.arima import auto_arima
from statsmodels.tsa.stattools import adfuller, kpss
from dateutil.relativedelta import relativedelta
from joblib import Parallel, delayed

# -------------------
# Helper functions
# -------------------

def check_stationarity(series):
    """Check stationarity with ADF, fallback to KPSS if needed."""
    try:
        adf_result = adfuller(series.dropna(), autolag="AIC")
        return adf_result[1] < 0.05  # stationary if p < 0.05
    except Exception:
        try:
            kpss_result = kpss(series.dropna(), regression="c", nlags="auto")
            return kpss_result[1] > 0.05  # stationary if p > 0.05
        except Exception:
            return None  # Inconclusive

def moving_average_forecast(series, horizon=6, window=3):
    """Simple moving average fallback forecast."""
    avg = series.rolling(window).mean().iloc[-1]
    return np.repeat(avg, horizon)

def forecast_one_category(cat, group, forecast_horizon):
    """Forecast for a single category."""
    series = group.sort_values("Date").set_index("Date")["Value"]

    # enforce monthly frequency (adjust to 'D' if daily data)
    series = series.asfreq("MS")

    stationary = check_stationarity(series)

    try:
        if stationary is None:
            model = auto_arima(series, d=1, seasonal=True, m=12,
                               error_action="ignore", suppress_warnings=True)
        else:
            model = auto_arima(series, seasonal=True, m=12,
                               test="adf" if stationary else "kpss",
                               error_action="ignore", suppress_warnings=True)

        forecast = model.predict(n_periods=forecast_horizon)

    except Exception:
        forecast = moving_average_forecast(series, forecast_horizon)

    forecast_dates = [series.index[-1] + relativedelta(months=i+1)
                      for i in range(forecast_horizon)]

    return pd.DataFrame({
        "Category": cat,
        "Forecast Date": forecast_dates,
        "Forecast Value": forecast
    })

def robust_auto_forecast_parallel(df, forecast_horizon=6, n_jobs=-1):
    """Run robust AutoARIMA across categories in parallel."""
    df["Date"] = pd.to_datetime(df["Date"])
    groups = [(cat, group) for cat, group in df.groupby("Category")]

    results = Parallel(n_jobs=n_jobs)(
        delayed(forecast_one_category)(cat, group, forecast_horizon)
        for cat, group in groups
    )

    return pd.concat(results, ignore_index=True)

# -------------------
# Example usage
# -------------------
# df = pd.DataFrame({
#     "Date": ["2022-01-01","2022-02-01","2022-03-01",
#              "2022-01-01","2022-02-01","2022-03-01"],
#     "Category": ["A","A","A","B","B","B"],
#     "Value": [100, 120, 130, 50, 55, 65]
# })
#
# forecast_df = robust_auto_forecast_parallel(df, forecast_horizon=6, n_jobs=-1)
# print(forecast_df)


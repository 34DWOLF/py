import pandas as pd
import numpy as np
from pmdarima.arima import auto_arima
from statsmodels.tsa.stattools import adfuller, kpss
from dateutil.relativedelta import relativedelta
from joblib import Parallel, delayed

# -------------------
# Helper functions
# -------------------

def check_stationarity(series):
    """Check stationarity with ADF, fallback to KPSS if needed."""
    try:
        adf_result = adfuller(series.dropna(), autolag="AIC")
        return adf_result[1] < 0.05  # stationary if p < 0.05
    except Exception:
        try:
            kpss_result = kpss(series.dropna(), regression="c", nlags="auto")
            return kpss_result[1] > 0.05  # stationary if p > 0.05
        except Exception:
            return None  # Inconclusive

def moving_average_forecast(series, horizon=6, window=3):
    """Simple moving average fallback forecast."""
    if len(series) < window:
        avg = series.mean() if len(series) > 0 else 0
        return np.repeat(avg, horizon), "Average"
    avg = series.rolling(window).mean().iloc[-1]
    return np.repeat(avg, horizon), "Moving Average"

def forecast_one_category(cat, group, forecast_horizon):
    """Forecast for a single category with strong fallbacks."""
    series = group.sort_values("Date").set_index("Date")["Value"]

    # enforce monthly frequency
    series = series.asfreq("MS")

    # Drop NaNs introduced by asfreq
    series = series.dropna()

    method_used = None

    # If too few points, bail out early with simple average
    if len(series) < 6:  # require at least ~half a year
        avg = series.mean() if len(series) > 0 else 0
        forecast = np.repeat(avg, forecast_horizon)
        method_used = "Average"
    else:
        stationary = check_stationarity(series)

        try:
            if stationary is None:
                model = auto_arima(series, d=1, seasonal=True, m=12,
                                   error_action="ignore", suppress_warnings=True)
            else:
                model = auto_arima(series, seasonal=True, m=12,
                                   test="adf" if stationary else "kpss",
                                   error_action="ignore", suppress_warnings=True)

            forecast = model.predict(n_periods=forecast_horizon)

            if np.any(np.isnan(forecast)):
                forecast, method_used = moving_average_forecast(series, forecast_horizon)
            else:
                method_used = "ARIMA"

        except Exception:
            forecast, method_used = moving_average_forecast(series, forecast_horizon)

    forecast_dates = [series.index[-1] + relativedelta(months=i+1)
                      for i in range(forecast_horizon)]

    return pd.DataFrame({
        "Category": cat,
        "Forecast Date": forecast_dates,
        "Forecast Value": forecast,
        "Forecast Method": method_used
    })

def robust_auto_forecast_parallel(df, forecast_horizon=6, n_jobs=-1):
    """Run robust AutoARIMA across categories in parallel."""
    df["Date"] = pd.to_datetime(df["Date"])
    groups = [(cat, group) for cat, group in df.groupby("Category")]

    results = Parallel(n_jobs=n_jobs)(
        delayed(forecast_one_category)(cat, group, forecast_horizon)
        for cat, group in groups
    )

    return pd.concat(results, ignore_index=True)

# -------------------
# Example usage
# -------------------
# df = pd.DataFrame({
#     "Date": ["2022-01-01","2022-02-01","2022-03-01",
#              "2022-01-01","2022-02-01","2022-03-01"],
#     "Category": ["A","A","A","B","B","B"],
#     "Value": [100, 120, 130, 50, 55, 65]
# })
#
# forecast_df = robust_auto_forecast_parallel(df, forecast_horizon=6, n_jobs=-1)
# print(forecast_df)

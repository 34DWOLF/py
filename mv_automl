# =======================================
# STEP 1: Imports
# =======================================
import pandas as pd
import numpy as np
from pycaret.time_series import *
from sklearn.inspection import permutation_importance
from joblib import Parallel, delayed
import warnings
warnings.filterwarnings("ignore")

# =======================================
# STEP 2: Load & Prepare Data
# =======================================
# Example structure — replace with your dataset
df = pd.DataFrame({
    'Date': pd.date_range(start='2015-01-01', periods=100, freq='MS'),
    'A': np.linspace(0, 100, 100) + np.random.normal(0, 5, 100),
    'B': np.linspace(10, 110, 100) + np.random.normal(0, 2, 100),
    'C': np.linspace(5, 105, 100),
    'D': np.linspace(2, 102, 100),
    'E': np.linspace(50, 150, 100),
    'F': np.linspace(80, 180, 100),
})

df['Date'] = pd.to_datetime(df['Date'])
df = df.sort_values('Date').set_index('Date')
df = df.asfreq('MS')  # Monthly frequency

# =======================================
# STEP 3: Define Target & Regressors
# =======================================
target_col = 'A'
regressors = ['B', 'C', 'D', 'E', 'F']
forecast_horizon = 12

# =======================================
# STEP 4: PyCaret Setup & AutoML
# =======================================
exp = TSForecastingExperiment()
exp.setup(
    data=df,
    target=target_col,
    fh=forecast_horizon,
    session_id=42,
    fold_strategy='sliding',
    numeric_imputation_target='ffill',
    numeric_imputation_exogenous='ffill',
    enforce_exogenous=True,
    exogenous_variables=regressors,
    verbose=True
)

best_model = exp.compare_models(sort='RMSE')
leaderboard = exp.pull()
print("\n=== MODEL LEADERBOARD ===")
print(leaderboard)

final_model = exp.finalize_model(best_model)

# =======================================
# STEP 5: Forecast & Diagnostics
# =======================================
forecast = exp.predict_model(final_model, fh=forecast_horizon)
print("\n=== FORECAST RESULTS ===")
print(forecast)

exp.plot_model(final_model, plot='forecast')
exp.plot_model(final_model, plot='diagnostics')

# =======================================
# STEP 6: Model-based Feature Importance
# =======================================
print("\n=== MODEL-BASED FEATURE IMPORTANCE ===")
try:
    exp.plot_model(final_model, plot='feature_importances')
except Exception as e:
    print("Model-based feature importance not supported:", e)

# =======================================
# STEP 7: Permutation Importance
# =======================================
print("\n=== PERMUTATION FEATURE IMPORTANCE ===")
try:
    X_test = exp.get_config('X_test')
    y_test = exp.get_config('y_test')

    r = permutation_importance(
        final_model,
        X_test,
        y_test,
        n_repeats=20,
        random_state=42,
        n_jobs=-1
    )

    sorted_idx = r.importances_mean.argsort()[::-1]
    for idx in sorted_idx:
        print(f"{X_test.columns[idx]}: {r.importances_mean[idx]:.4f}")
except Exception as e:
    print("Permutation importance failed:", e)

# =======================================
# STEP 8: Parallel Leave-One-Regressor-Out Analysis
# =======================================
print("\n=== PARALLEL LEAVE-ONE-REGRESSOR-OUT IMPACT ANALYSIS ===")
base_rmse = leaderboard.iloc[0]['RMSE']

def evaluate_without_regressor(reg):
    """Train and evaluate model without a specific regressor."""
    reduced_regs = [r for r in regressors if r != reg]
    exp_tmp = TSForecastingExperiment()
    exp_tmp.setup(
        data=df,
        target=target_col,
        fh=forecast_horizon,
        session_id=42,
        fold_strategy='sliding',
        numeric_imputation_target='ffill',
        numeric_imputation_exogenous='ffill',
        enforce_exogenous=True,
        exogenous_variables=reduced_regs,
        verbose=False
    )
    m = exp_tmp.create_model(best_model)
    exp_tmp.finalize_model(m)
    rmse = exp_tmp.pull().iloc[0]['RMSE']
    return (reg, rmse, rmse - base_rmse)

# Run in parallel across all regressors
impact_results = Parallel(n_jobs=-1, backend="loky")(
    delayed(evaluate_without_regressor)(reg) for reg in regressors
)

impact_df = pd.DataFrame(impact_results, columns=['Regressor', 'RMSE_without', 'ΔRMSE'])
impact_df = impact_df.sort_values('ΔRMSE', ascending=False)
print("\n=== REGRESSOR IMPACT SUMMARY ===")
print(impact_df)

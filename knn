import pandas as pd
import numpy as np
from sklearn.neighbors import KNeighborsRegressor
from sklearn.preprocessing import StandardScaler
from statsmodels.tsa.seasonal import seasonal_decompose
from typing import List, Tuple, Dict
import warnings
warnings.filterwarnings('ignore')


class KNNTimeSeriesForecaster:
    """
    K-Nearest Neighbors forecaster with conditional deseasonalization and detrending.
    """
    
    def __init__(
        self,
        date_col: str = 'date',
        target_col: str = 'value',
        regressor_cols: List[str] = None,
        n_neighbors: int = 5,
        seasonal_period: int = 12,
        forecast_horizon: int = 1,
        backtest_months: int = 6
    ):
        """
        Initialize the KNN Time Series Forecaster.
        
        Parameters:
        -----------
        date_col : str
            Name of the date column
        target_col : str
            Name of the target variable column
        regressor_cols : List[str]
            List of regressor column names
        n_neighbors : int
            Number of neighbors for KNN
        seasonal_period : int
            Seasonal period for decomposition (12 for monthly data)
        forecast_horizon : int
            Number of periods to forecast
        backtest_months : int
            Number of months to use for backtesting
        """
        self.date_col = date_col
        self.target_col = target_col
        self.regressor_cols = regressor_cols or []
        self.n_neighbors = n_neighbors
        self.seasonal_period = seasonal_period
        self.forecast_horizon = forecast_horizon
        self.backtest_months = backtest_months
        
        self.scaler = StandardScaler()
        self.trend = None
        self.seasonal = None
        self.model = None
        
    def _detrend_deseasonalize(self, series: pd.Series) -> Tuple[pd.Series, pd.Series, pd.Series]:
        """
        Decompose time series into trend, seasonal, and residual components.
        
        Returns:
        --------
        trend, seasonal, residual
        """
        if len(series) < 2 * self.seasonal_period:
            # If not enough data for decomposition, return original series
            trend = pd.Series(np.linspace(series.iloc[0], series.iloc[-1], len(series)), index=series.index)
            seasonal = pd.Series(0, index=series.index)
            residual = series - trend
            return trend, seasonal, residual
        
        decomposition = seasonal_decompose(
            series, 
            model='additive', 
            period=self.seasonal_period,
            extrapolate_trend='freq'
        )
        
        return decomposition.trend, decomposition.seasonal, decomposition.resid
    
    def _create_features(self, df: pd.DataFrame, include_lags: bool = True) -> pd.DataFrame:
        """
        Create feature matrix for KNN model.
        """
        features = df.copy()
        
        if include_lags:
            # Create lag features
            for lag in range(1, min(13, len(df))):
                features[f'lag_{lag}'] = df[self.target_col].shift(lag)
        
        # Add time-based features
        features['month'] = pd.to_datetime(features[self.date_col]).dt.month
        features['quarter'] = pd.to_datetime(features[self.date_col]).dt.quarter
        
        # Include external regressors
        for reg_col in self.regressor_cols:
            if reg_col in df.columns:
                features[f'reg_{reg_col}'] = df[reg_col]
        
        return features
    
    def fit(self, df: pd.DataFrame) -> 'KNNTimeSeriesForecaster':
        """
        Fit the KNN model with detrending and deseasonalization.
        """
        df = df.sort_values(self.date_col).reset_index(drop=True)
        
        # Decompose the time series
        self.trend, self.seasonal, residual = self._detrend_deseasonalize(df[self.target_col])
        
        # Store the last values for forecasting
        self.last_trend_value = self.trend.iloc[-1]
        self.last_seasonal_pattern = self.seasonal.tail(self.seasonal_period).values
        
        # Create features
        features_df = self._create_features(df, include_lags=True)
        
        # Prepare training data (drop NaN from lagged features)
        train_df = features_df.dropna()
        
        # Select feature columns
        feature_cols = [col for col in train_df.columns 
                       if col not in [self.date_col, self.target_col] 
                       and not col.startswith('reg_')]
        
        # Add regressor columns
        feature_cols.extend([col for col in train_df.columns if col.startswith('reg_')])
        
        X_train = train_df[feature_cols]
        y_train = residual.loc[train_df.index]
        
        # Scale features
        X_train_scaled = self.scaler.fit_transform(X_train)
        
        # Fit KNN model on residuals
        self.model = KNeighborsRegressor(n_neighbors=self.n_neighbors)
        self.model.fit(X_train_scaled, y_train)
        
        self.feature_cols = feature_cols
        self.fitted_df = df.copy()
        
        return self
    
    def predict(self, df_full: pd.DataFrame) -> np.ndarray:
        """
        Make predictions for the forecast horizon.
        
        Parameters:
        -----------
        df_full : pd.DataFrame
            Full dataset including historical data AND future periods with regressor values.
            The last `forecast_horizon` rows should contain the future regressor values.
        
        Returns:
        --------
        predictions : np.ndarray
            Forecasted values
        """
        df_full = df_full.copy()
        
        # Identify where historical data ends (last row with target value)
        last_historical_idx = df_full[self.target_col].last_valid_index()
        
        predictions = []
        current_df = df_full.iloc[:last_historical_idx + 1].copy()
        
        for h in range(self.forecast_horizon):
            # Create features for current step
            features_df = self._create_features(current_df, include_lags=True)
            
            # Get the last valid row (most recent with all features)
            valid_features = features_df.dropna()
            if len(valid_features) == 0:
                raise ValueError("Not enough historical data to create features for prediction")
            
            X_pred = valid_features.iloc[[-1]][self.feature_cols].copy()
            
            # Get future regressor values from the full dataset
            future_idx = last_historical_idx + h + 1
            if future_idx < len(df_full):
                for reg_col in self.regressor_cols:
                    reg_feature_col = f'reg_{reg_col}'
                    if reg_feature_col in X_pred.columns and reg_col in df_full.columns:
                        X_pred.loc[:, reg_feature_col] = df_full.iloc[future_idx][reg_col]
            
            # Scale and predict residual
            X_pred_scaled = self.scaler.transform(X_pred)
            residual_pred = self.model.predict(X_pred_scaled)[0]
            
            # Reconstruct: add trend and seasonal components
            trend_pred = self.last_trend_value + (h + 1) * (self.trend.iloc[-1] - self.trend.iloc[-2])
            seasonal_idx = (len(self.seasonal) + h) % self.seasonal_period
            seasonal_pred = self.last_seasonal_pattern[seasonal_idx]
            
            final_pred = trend_pred + seasonal_pred + residual_pred
            predictions.append(final_pred)
            
            # Update dataframe with prediction for next iteration
            new_date = pd.to_datetime(current_df[self.date_col].iloc[-1]) + pd.DateOffset(months=1)
            new_row = {self.date_col: new_date, self.target_col: final_pred}
            
            # Add regressor values from future dataset if available
            if future_idx < len(df_full):
                for reg_col in self.regressor_cols:
                    if reg_col in df_full.columns:
                        new_row[reg_col] = df_full.iloc[future_idx][reg_col]
            
            current_df = pd.concat([current_df, pd.DataFrame([new_row])], ignore_index=True)
        
        return np.array(predictions)
    
    def backtest(self, df: pd.DataFrame) -> Dict:
        """
        Perform iterative backtest over the specified number of months.
        
        Returns:
        --------
        results : Dict
            Dictionary containing backtest results and metrics
        """
        df = df.sort_values(self.date_col).reset_index(drop=True)
        
        backtest_results = []
        
        # Start backtest from (total_length - backtest_months)
        train_end_idx = len(df) - self.backtest_months
        
        for i in range(self.backtest_months):
            # Split data
            train_df = df.iloc[:train_end_idx + i]
            test_idx = train_end_idx + i
            
            if test_idx >= len(df):
                break
            
            actual_value = df.iloc[test_idx][self.target_col]
            actual_date = df.iloc[test_idx][self.date_col]
            
            # Fit model on training data
            self.fit(train_df)
            
            # Create extended dataframe with future regressors for prediction
            test_df_with_regressors = pd.concat([
                train_df,
                df.iloc[test_idx:test_idx + self.forecast_horizon][[self.date_col] + self.regressor_cols]
            ], ignore_index=True)
            
            # Predict
            prediction = self.predict(test_df_with_regressors)[0]
            
            backtest_results.append({
                'date': actual_date,
                'actual': actual_value,
                'predicted': prediction,
                'error': actual_value - prediction,
                'abs_error': abs(actual_value - prediction),
                'pct_error': 100 * (actual_value - prediction) / actual_value if actual_value != 0 else np.nan
            })
        
        results_df = pd.DataFrame(backtest_results)
        
        # Calculate metrics
        mae = results_df['abs_error'].mean()
        rmse = np.sqrt((results_df['error'] ** 2).mean())
        mape = results_df['pct_error'].abs().mean()
        
        return {
            'results_df': results_df,
            'mae': mae,
            'rmse': rmse,
            'mape': mape
        }


# Example usage
if __name__ == "__main__":
    # Create sample data
    np.random.seed(42)
    dates = pd.date_range(start='2020-01-31', periods=51, freq='ME')  # 48 historical + 3 future
    
    # Generate synthetic time series with trend, seasonality, and noise
    trend = np.linspace(100, 150, 48)
    seasonal = 10 * np.sin(np.arange(48) * 2 * np.pi / 12)
    noise = np.random.normal(0, 5, 48)
    values = trend + seasonal + noise
    
    # Generate synthetic regressors for ALL periods (including future)
    regressor1 = np.random.normal(50, 10, 51)
    regressor2 = np.random.normal(200, 30, 51)
    
    # Create dataframe with historical values and future regressors
    df = pd.DataFrame({
        'date': dates,
        'value': list(values) + [np.nan] * 3,  # Last 3 are unknown (to be forecasted)
        'economic_indicator': regressor1,
        'market_index': regressor2
    })
    
    # Initialize forecaster
    forecaster = KNNTimeSeriesForecaster(
        date_col='date',
        target_col='value',
        regressor_cols=['economic_indicator', 'market_index'],
        n_neighbors=5,
        seasonal_period=12,
        forecast_horizon=3,
        backtest_months=6
    )
    
    # Run backtest (only on historical data)
    print("Running backtest...")
    df_historical = df[df['value'].notna()].copy()
    backtest_results = forecaster.backtest(df_historical)
    
    print("\n=== BACKTEST RESULTS ===")
    print(f"MAE: {backtest_results['mae']:.2f}")
    print(f"RMSE: {backtest_results['rmse']:.2f}")
    print(f"MAPE: {backtest_results['mape']:.2f}%")
    print("\nDetailed Results:")
    print(backtest_results['results_df'].to_string(index=False))
    
    # Fit on full historical data and forecast
    print("\n=== FINAL FORECAST ===")
    forecaster.fit(df_historical)
    
    # The future regressor values are already in the full dataset
    # Just pass the complete dataset (historical + future rows with regressors)
    predictions = forecaster.predict(df)
    
    print(f"Next {forecaster.forecast_horizon} period forecasts:")
    for i, pred in enumerate(predictions, 1):
        forecast_date = df[df['value'].isna()].iloc[i-1]['date']
        print(f"  Period {i} ({forecast_date.strftime('%Y-%m-%d')}): {pred:.2f}")
# ---------- STEP 5: Forecast future months ----------

def forecast_future_months(final_artifacts, n_periods=3, future_regressors=None):
    """
    Generate multi-month forecasts using the trained final KNN-CSD model.
    Optionally provide future regressors (R1, R2) as a DataFrame with Date + values.
    """

    model = final_artifacts['model']
    scaler = final_artifacts['scaler']
    features = final_artifacts['features']
    lags = final_artifacts['lags']
    df_forecast = final_artifacts['deseasonalized_df'].copy()

    forecast_records = []

    for step in range(1, n_periods + 1):
        last_date = df_forecast['Date'].max()
        next_date = last_date + pd.offsets.MonthEnd(1)

        # Handle regressors: use provided future values if available, else last known
        if future_regressors is not None:
            match = future_regressors[future_regressors['Date'] == next_date]
            if not match.empty:
                r1_val = match['R1'].values[0]
                r2_val = match['R2'].values[0]
            else:
                r1_val = df_forecast['R1'].iloc[-1]
                r2_val = df_forecast['R2'].iloc[-1]
        else:
            r1_val = df_forecast['R1'].iloc[-1]
            r2_val = df_forecast['R2'].iloc[-1]

        # Build lagged residuals
        new_row = {
            'Date': next_date,
            'Month': next_date.month,
            'R1': r1_val,
            'R2': r2_val,
        }
        for lag in lags:
            new_row[f'lag_{lag}'] = df_forecast['resid'].iloc[-lag]

        # Predict residual
        X_new = pd.DataFrame([new_row])[features]
        X_new_scaled = scaler.transform(X_new)
        pred_resid = model.predict(X_new_scaled)[0]

        # Seasonal component
        month_seasonal = df_forecast.groupby('Month')['seasonal'].mean().get(next_date.month, 0)

        # Trend component (linear extrapolation)
        trend_model = LinearRegression()
        X_trend = np.arange(len(df_forecast)).reshape(-1,1)
        y_trend = df_forecast['trend'].values
        trend_model.fit(X_trend, y_trend)
        future_trend = trend_model.predict([[len(df_forecast)+1]])[0]

        forecast_value = pred_resid + month_seasonal + future_trend

        forecast_records.append({
            'Date': next_date,
            'Forecast': forecast_value,
            'Predicted_Resid': pred_resid,
            'Seasonal_Component': month_seasonal,
            'Trend_Component': future_trend
        })

        # Append this forecast row so next iteration has updated lags
        new_append = {
            'Date': next_date,
            'Value': forecast_value,
            'R1': r1_val,
            'R2': r2_val,
            'resid': pred_resid,
            'seasonal': month_seasonal,
            'trend': future_trend,
            'Month': next_date.month
        }
        df_forecast = pd.concat([df_forecast, pd.DataFrame([new_append])], ignore_index=True)

    return pd.DataFrame(forecast_records)




# Let's say we've already run:
# backtest_df, rmse_summary, final_artifacts = knn_csd_backtest_parallel(df, backtest_horizon=6)

future_forecast_df = forecast_future_months(
    final_artifacts,
    n_periods=6,  # forecast 6 months ahead
    future_regressors=None  # or provide a DataFrame if you have known future R1/R2
)

print("\nðŸ”® Future Forecasts:")
print(future_forecast_df)
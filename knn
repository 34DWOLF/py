import pandas as pd
import numpy as np
from sklearn.neighbors import KNeighborsRegressor
from sklearn.preprocessing import StandardScaler
from statsmodels.tsa.seasonal import seasonal_decompose
from typing import List, Tuple, Dict
import warnings
warnings.filterwarnings('ignore')


class KNNTimeSeriesForecaster:
    """
    K-Nearest Neighbors forecaster with conditional deseasonalization and detrending.
    Automatically tunes n_neighbors and seasonal_period based on backtest performance.
    """
    
    def __init__(
        self,
        date_col: str = 'date',
        target_col: str = 'value',
        regressor_cols: List[str] = None,
        n_neighbors: int = None,
        seasonal_period: int = None,
        forecast_horizon: int = 1,
        backtest_months: int = 6,
        auto_tune: bool = True
    ):
        """
        Initialize the KNN Time Series Forecaster.
        
        Parameters:
        -----------
        date_col : str
            Name of the date column
        target_col : str
            Name of the target variable column
        regressor_cols : List[str]
            List of regressor column names
        n_neighbors : int
            Number of neighbors for KNN. If None and auto_tune=True, will be optimized
        seasonal_period : int
            Seasonal period for decomposition. If None and auto_tune=True, will be optimized
        forecast_horizon : int
            Number of periods to forecast
        backtest_months : int
            Number of months to use for backtesting
        auto_tune : bool
            If True, automatically tune n_neighbors and seasonal_period
        """
        self.date_col = date_col
        self.target_col = target_col
        self.regressor_cols = regressor_cols or []
        self.n_neighbors = n_neighbors
        self.seasonal_period = seasonal_period
        self.forecast_horizon = forecast_horizon
        self.backtest_months = backtest_months
        self.auto_tune = auto_tune
        
        self.scaler = StandardScaler()
        self.trend = None
        self.seasonal = None
        self.model = None
        self.best_params = None
        
    def _detrend_deseasonalize(self, series: pd.Series, seasonal_period: int) -> Tuple[pd.Series, pd.Series, pd.Series]:
        """
        Decompose time series into trend, seasonal, and residual components.
        
        Returns:
        --------
        trend, seasonal, residual
        """
        if len(series) < 2 * seasonal_period:
            # If not enough data for decomposition, return original series
            trend = pd.Series(np.linspace(series.iloc[0], series.iloc[-1], len(series)), index=series.index)
            seasonal = pd.Series(0, index=series.index)
            residual = series - trend
            return trend, seasonal, residual
        
        decomposition = seasonal_decompose(
            series, 
            model='additive', 
            period=seasonal_period,
            extrapolate_trend='freq'
        )
        
        return decomposition.trend, decomposition.seasonal, decomposition.resid
    
    def _create_features(self, df: pd.DataFrame, include_lags: bool = True) -> pd.DataFrame:
        """
        Create feature matrix for KNN model.
        """
        features = df.copy()
        
        if include_lags:
            # Create lag features
            for lag in range(1, min(13, len(df))):
                features[f'lag_{lag}'] = df[self.target_col].shift(lag)
        
        # Add time-based features
        features['month'] = pd.to_datetime(features[self.date_col]).dt.month
        features['quarter'] = pd.to_datetime(features[self.date_col]).dt.quarter
        
        # Include external regressors
        for reg_col in self.regressor_cols:
            if reg_col in df.columns:
                features[f'reg_{reg_col}'] = df[reg_col]
        
        return features
    
    def _fit_model(self, df: pd.DataFrame, n_neighbors: int, seasonal_period: int) -> None:
        """
        Internal method to fit the model with specific parameters.
        """
        df = df.sort_values(self.date_col).reset_index(drop=True)
        
        # Decompose the time series
        self.trend, self.seasonal, residual = self._detrend_deseasonalize(
            df[self.target_col], seasonal_period
        )
        
        # Store the last values for forecasting
        self.last_trend_value = self.trend.iloc[-1]
        self.last_seasonal_pattern = self.seasonal.tail(seasonal_period).values
        
        # Create features
        features_df = self._create_features(df, include_lags=True)
        
        # Prepare training data (drop NaN from lagged features)
        train_df = features_df.dropna()
        
        # Select feature columns
        feature_cols = [col for col in train_df.columns 
                       if col not in [self.date_col, self.target_col] 
                       and not col.startswith('reg_')]
        
        # Add regressor columns
        feature_cols.extend([col for col in train_df.columns if col.startswith('reg_')])
        
        X_train = train_df[feature_cols]
        y_train = residual.loc[train_df.index]
        
        # Scale features
        X_train_scaled = self.scaler.fit_transform(X_train)
        
        # Fit KNN model on residuals
        self.model = KNeighborsRegressor(n_neighbors=n_neighbors)
        self.model.fit(X_train_scaled, y_train)
        
        self.feature_cols = feature_cols
        self.fitted_df = df.copy()
        self.current_n_neighbors = n_neighbors
        self.current_seasonal_period = seasonal_period
    
    def fit(self, df: pd.DataFrame) -> 'KNNTimeSeriesForecaster':
        """
        Fit the KNN model with detrending and deseasonalization.
        If auto_tune=True and parameters not specified, finds optimal parameters.
        """
        df = df.sort_values(self.date_col).reset_index(drop=True)
        
        # Determine parameters to use
        if self.auto_tune and (self.n_neighbors is None or self.seasonal_period is None):
            print("Auto-tuning parameters...")
            self.best_params = self._tune_parameters(df)
            n_neighbors = self.best_params['n_neighbors']
            seasonal_period = self.best_params['seasonal_period']
            print(f"Best parameters: n_neighbors={n_neighbors}, seasonal_period={seasonal_period}")
            print(f"Best MAE: {self.best_params['mae']:.2f}")
        else:
            n_neighbors = self.n_neighbors or 5
            seasonal_period = self.seasonal_period or 12
        
        # Fit with optimal or specified parameters
        self._fit_model(df, n_neighbors, seasonal_period)
        
        return self
    
    def _tune_parameters(self, df: pd.DataFrame) -> Dict:
        """
        Find optimal n_neighbors and seasonal_period through grid search on backtest.
        """
        # Define parameter grid
        if self.n_neighbors is None:
            n_neighbors_grid = [3, 5, 7, 10, 15]
        else:
            n_neighbors_grid = [self.n_neighbors]
        
        if self.seasonal_period is None:
            seasonal_period_grid = [4, 6, 12]  # Quarterly, semi-annual, annual
        else:
            seasonal_period_grid = [self.seasonal_period]
        
        best_mae = float('inf')
        best_params = {'n_neighbors': 5, 'seasonal_period': 12, 'mae': best_mae}
        
        # Grid search
        for n_neighbors in n_neighbors_grid:
            for seasonal_period in seasonal_period_grid:
                try:
                    # Run backtest with these parameters
                    results = self._backtest_with_params(df, n_neighbors, seasonal_period)
                    mae = results['mae']
                    
                    if mae < best_mae:
                        best_mae = mae
                        best_params = {
                            'n_neighbors': n_neighbors,
                            'seasonal_period': seasonal_period,
                            'mae': mae,
                            'rmse': results['rmse'],
                            'mape': results['mape']
                        }
                except Exception as e:
                    # Skip parameter combinations that fail
                    continue
        
        return best_params
    
    def _backtest_with_params(self, df: pd.DataFrame, n_neighbors: int, seasonal_period: int) -> Dict:
        """
        Perform backtest with specific parameters.
        """
        df = df.sort_values(self.date_col).reset_index(drop=True)
        
        backtest_results = []
        
        # Start backtest from (total_length - backtest_months)
        train_end_idx = len(df) - self.backtest_months
        
        if train_end_idx < 2 * seasonal_period:
            raise ValueError("Not enough data for backtest with this seasonal period")
        
        for i in range(self.backtest_months):
            # Split data
            train_df = df.iloc[:train_end_idx + i]
            test_idx = train_end_idx + i
            
            if test_idx >= len(df):
                break
            
            actual_value = df.iloc[test_idx][self.target_col]
            
            # Fit model on training data
            self._fit_model(train_df, n_neighbors, seasonal_period)
            
            # Predict (only need 1-step ahead for backtest)
            # Create future regressor data if needed
            future_regressors = {}
            for reg_col in self.regressor_cols:
                if reg_col in df.columns:
                    future_regressors[reg_col] = [df.iloc[test_idx][reg_col]]
            
            prediction = self._predict_internal(train_df, future_regressors, horizon=1)[0]
            
            backtest_results.append({
                'actual': actual_value,
                'predicted': prediction,
                'error': actual_value - prediction,
                'abs_error': abs(actual_value - prediction),
                'pct_error': 100 * (actual_value - prediction) / actual_value if actual_value != 0 else np.nan
            })
        
        results_df = pd.DataFrame(backtest_results)
        
        # Calculate metrics
        mae = results_df['abs_error'].mean()
        rmse = np.sqrt((results_df['error'] ** 2).mean())
        mape = results_df['pct_error'].abs().mean()
        
        return {
            'results_df': results_df,
            'mae': mae,
            'rmse': rmse,
            'mape': mape
        }
    
    def _predict_internal(self, df_historical: pd.DataFrame, future_regressors: Dict, horizon: int) -> np.ndarray:
        """
        Internal prediction method.
        
        Parameters:
        -----------
        df_historical : pd.DataFrame
            Historical data only (no future rows)
        future_regressors : Dict
            Dictionary with regressor names as keys and lists of future values
        horizon : int
            Number of periods to forecast
        """
        predictions = []
        current_df = df_historical.copy()
        
        for h in range(horizon):
            # Create features for current step
            features_df = self._create_features(current_df, include_lags=True)
            
            # Get the last valid row (most recent with all features)
            valid_features = features_df.dropna()
            if len(valid_features) == 0:
                raise ValueError("Not enough historical data to create features for prediction")
            
            X_pred = valid_features.iloc[[-1]][self.feature_cols].copy()
            
            # Update with future regressor values
            for reg_col in self.regressor_cols:
                reg_feature_col = f'reg_{reg_col}'
                if reg_feature_col in X_pred.columns and reg_col in future_regressors:
                    if h < len(future_regressors[reg_col]):
                        X_pred.loc[:, reg_feature_col] = future_regressors[reg_col][h]
            
            # Scale and predict residual
            X_pred_scaled = self.scaler.transform(X_pred)
            residual_pred = self.model.predict(X_pred_scaled)[0]
            
            # Reconstruct: add trend and seasonal components
            trend_pred = self.last_trend_value + (h + 1) * (self.trend.iloc[-1] - self.trend.iloc[-2])
            seasonal_idx = (len(self.seasonal) + h) % self.current_seasonal_period
            seasonal_pred = self.last_seasonal_pattern[seasonal_idx]
            
            final_pred = trend_pred + seasonal_pred + residual_pred
            predictions.append(final_pred)
            
            # Update dataframe with prediction for next iteration
            new_date = pd.to_datetime(current_df[self.date_col].iloc[-1]) + pd.DateOffset(months=1)
            new_row = {self.date_col: new_date, self.target_col: final_pred}
            
            # Add regressor values
            for reg_col in self.regressor_cols:
                if reg_col in future_regressors and h < len(future_regressors[reg_col]):
                    new_row[reg_col] = future_regressors[reg_col][h]
            
            current_df = pd.concat([current_df, pd.DataFrame([new_row])], ignore_index=True)
        
        return np.array(predictions)
    
    def predict(self, df: pd.DataFrame, future_regressors: Dict = None) -> np.ndarray:
        """
        Make predictions for the forecast horizon.
        
        Parameters:
        -----------
        df : pd.DataFrame
            Historical data only (no future rows with NaN values)
        future_regressors : Dict, optional
            Dictionary with regressor names as keys and lists of future values
            Example: {'economic_indicator': [52.3, 53.1, 54.2], 'market_index': [215.7, 220.5, 225.3]}
        
        Returns:
        --------
        predictions : np.ndarray
            Forecasted values
        """
        if future_regressors is None:
            future_regressors = {}
        
        return self._predict_internal(df, future_regressors, self.forecast_horizon)
    
    def backtest(self, df: pd.DataFrame) -> Dict:
        """
        Perform iterative backtest over the specified number of months.
        Uses the fitted model's parameters (or tunes if not yet fitted).
        
        Returns:
        --------
        results : Dict
            Dictionary containing backtest results and metrics
        """
        df = df.sort_values(self.date_col).reset_index(drop=True)
        
        # Use current parameters or defaults
        n_neighbors = self.current_n_neighbors if hasattr(self, 'current_n_neighbors') else (self.n_neighbors or 5)
        seasonal_period = self.current_seasonal_period if hasattr(self, 'current_seasonal_period') else (self.seasonal_period or 12)
        
        backtest_results = []
        
        # Start backtest from (total_length - backtest_months)
        train_end_idx = len(df) - self.backtest_months
        
        for i in range(self.backtest_months):
            # Split data
            train_df = df.iloc[:train_end_idx + i]
            test_idx = train_end_idx + i
            
            if test_idx >= len(df):
                break
            
            actual_value = df.iloc[test_idx][self.target_col]
            actual_date = df.iloc[test_idx][self.date_col]
            
            # Fit model on training data
            self._fit_model(train_df, n_neighbors, seasonal_period)
            
            # Create future regressor data
            future_regressors = {}
            for reg_col in self.regressor_cols:
                if reg_col in df.columns:
                    future_regressors[reg_col] = [df.iloc[test_idx][reg_col]]
            
            # Predict
            prediction = self._predict_internal(train_df, future_regressors, horizon=1)[0]
            
            backtest_results.append({
                'date': actual_date,
                'actual': actual_value,
                'predicted': prediction,
                'error': actual_value - prediction,
                'abs_error': abs(actual_value - prediction),
                'pct_error': 100 * (actual_value - prediction) / actual_value if actual_value != 0 else np.nan
            })
        
        results_df = pd.DataFrame(backtest_results)
        
        # Calculate metrics
        mae = results_df['abs_error'].mean()
        rmse = np.sqrt((results_df['error'] ** 2).mean())
        mape = results_df['pct_error'].abs().mean()
        
        return {
            'results_df': results_df,
            'mae': mae,
            'rmse': rmse,
            'mape': mape
        }


# Example usage
if __name__ == "__main__":
    # Create sample data - ONLY HISTORICAL DATA (no future rows)
    np.random.seed(42)
    dates = pd.date_range(start='2020-01-31', periods=48, freq='ME')
    
    # Generate synthetic time series with trend, seasonality, and noise
    trend = np.linspace(100, 150, 48)
    seasonal = 10 * np.sin(np.arange(48) * 2 * np.pi / 12)
    noise = np.random.normal(0, 5, 48)
    values = trend + seasonal + noise
    
    # Generate synthetic regressors (historical only)
    regressor1 = np.random.normal(50, 10, 48)
    regressor2 = np.random.normal(200, 30, 48)
    
    df = pd.DataFrame({
        'date': dates,
        'value': values,
        'economic_indicator': regressor1,
        'market_index': regressor2
    })
    
    print("Dataset shape:", df.shape)
    print("Last few rows:")
    print(df.tail())
    
    # Initialize forecaster with auto-tuning
    forecaster = KNNTimeSeriesForecaster(
        date_col='date',
        target_col='value',
        regressor_cols=['economic_indicator', 'market_index'],
        forecast_horizon=3,
        backtest_months=6,
        auto_tune=True  # Will automatically find best n_neighbors and seasonal_period
    )
    
    # Fit the model (will auto-tune parameters)
    print("\n" + "="*60)
    forecaster.fit(df)
    
    # Run backtest with the tuned parameters
    print("\n" + "="*60)
    print("Running backtest with optimal parameters...")
    backtest_results = forecaster.backtest(df)
    
    print("\n=== BACKTEST RESULTS ===")
    print(f"MAE: {backtest_results['mae']:.2f}")
    print(f"RMSE: {backtest_results['rmse']:.2f}")
    print(f"MAPE: {backtest_results['mape']:.2f}%")
    print("\nDetailed Results:")
    print(backtest_results['results_df'].to_string(index=False))
    
    # Make future predictions
    print("\n" + "="*60)
    print("=== FINAL FORECAST ===")
    
    # Provide future regressor values (you need to know or estimate these)
    future_regressors = {
        'economic_indicator': [52.5, 53.2, 54.1],  # Your forecasted/planned values
        'market_index': [218.0, 222.5, 225.0]
    }
    
    predictions = forecaster.predict(df, future_regressors)
    
    print(f"Next {forecaster.forecast_horizon} period forecasts:")
    last_date = pd.to_datetime(df[forecaster.date_col].iloc[-1])
    for i, pred in enumerate(predictions, 1):
        forecast_date = last_date + pd.DateOffset(months=i)
        print(f"  Period {i} ({forecast_date.strftime('%Y-%m-%d')}): {pred:.2f}")

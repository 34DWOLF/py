# Import required libraries
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.stattools import adfuller, acf, pacf
from statsmodels.tsa.arima.model import ARIMA
from statsmodels.graphics.tsaplots import plot_acf, plot_pacf
from sklearn.linear_model import LinearRegression
from datetime import datetime, timedelta
import warnings
from dateutil.relativedelta import relativedelta

# Suppress warnings for cleaner output
warnings.filterwarnings("ignore")

# Set plot style for better visualizations
plt.style.use('seaborn-whitegrid')

# Load data (replace with your actual file path in Databricks)
file_path = "/dbfs/FileStore/your_data_file.csv"  # Update this path
df = pd.read_csv(file_path)

# Ensure Date is in datetime format
df['Date'] = pd.to_datetime(df['Date'])

# Since data is monthly, ensure it's set to the first day of each month for consistency
df['Date'] = df['Date'].apply(lambda x: x.replace(day=1))

# Display the first few rows
print("Data sample:")
display(df.head())

# Get basic statistics
print("\nData summary:")
display(df.describe())

# Check for missing values
print("\nMissing values:")
display(df.isnull().sum())

# Get unique owners
owners = df['Owner'].unique()
print(f"\nNumber of unique owners: {len(owners)}")
print("Owners:", owners)

# Count data points per owner
owner_counts = df.groupby('Owner').size().reset_index(name='Count')
print("\nData points per owner:")
display(owner_counts)

# Check date ranges per owner
date_ranges = []
for owner in owners:
    owner_data = df[df['Owner'] == owner].sort_values('Date')
    date_ranges.append({
        'Owner': owner,
        'First Month': owner_data['Date'].min().strftime('%Y-%m'),
        'Last Month': owner_data['Date'].max().strftime('%Y-%m'),
        'Months Count': len(owner_data),
        'Is Continuous': len(owner_data) == ((owner_data['Date'].max() - owner_data['Date'].min()).days // 30) + 1
    })

date_range_df = pd.DataFrame(date_ranges)
print("\nDate ranges per owner:")
display(date_range_df)

# Define stationarity check function
def check_stationarity(timeseries, owner_name=None):
    """
    Test stationarity using Augmented Dickey-Fuller test
    """
    # Perform ADF test
    result = adfuller(timeseries)
    
    # Extract results
    dftest = pd.Series(
        result[0:4],
        index=['Test Statistic', 'p-value', '#Lags Used', 'Number of Observations Used']
    )
    
    for key, value in result[4].items():
        dftest[f'Critical Value ({key})'] = value
    
    # Determine if stationary
    is_stationary = result[1] <= 0.05
    
    # Display results
    if owner_name:
        print(f"Results of Augmented Dickey-Fuller Test for Owner: {owner_name}")
    else:
        print("Results of Augmented Dickey-Fuller Test:")
    
    print(dftest)
    print(f"Is the series stationary? {'Yes' if is_stationary else 'No'}")
    print("-" * 50)
    
    return is_stationary, result[1]

# Plot time series for each owner
plt.figure(figsize=(14, len(owners) * 4))

for i, owner in enumerate(owners):
    owner_data = df[df['Owner'] == owner].sort_values('Date')
    
    plt.subplot(len(owners), 1, i+1)
    plt.plot(owner_data['Date'], owner_data['Value'], marker='o', linestyle='-', label=f"Data Points: {len(owner_data)}")
    plt.title(f'Monthly Time Series for Owner: {owner}')
    plt.ylabel('Value')
    plt.grid(True)
    plt.legend()
    
    # Format x-axis to show month-year
    plt.gca().xaxis.set_major_formatter(plt.matplotlib.dates.DateFormatter('%b %Y'))
    plt.gcf().autofmt_xdate()

plt.tight_layout()
display(plt.gcf())
plt.close()

# Test stationarity for each owner
stationarity_results = {}

for owner in owners:
    owner_data = df[df['Owner'] == owner].sort_values('Date')
    values = owner_data['Value'].values
    
    # Only test if we have enough data points
    if len(values) >= 8:  # Minimum required for adfuller test
        is_stationary, p_value = check_stationarity(values, owner)
        stationarity_results[owner] = {
            'is_stationary': is_stationary,
            'p_value': p_value,
            'data_points': len(values)
        }
    else:
        print(f"Owner {owner} has only {len(values)} months of data, not enough for stationarity test.")
        stationarity_results[owner] = {
            'is_stationary': None,
            'p_value': None,
            'data_points': len(values)
        }

# Function to analyze and plot ACF and PACF
def analyze_acf_pacf(timeseries, owner_name, max_lags=10):
    # Compute ACF and PACF
    acf_values = acf(timeseries, nlags=max_lags, fft=True)
    pacf_values = pacf(timeseries, nlags=max_lags, method='ols')
    
    # Plot
    fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(12, 8))
    
    # ACF plot
    plot_acf(timeseries, ax=ax1, lags=max_lags)
    ax1.set_title(f'Autocorrelation Function for Owner: {owner_name}')
    
    # PACF plot
    plot_pacf(timeseries, ax=ax2, lags=max_lags)
    ax2.set_title(f'Partial Autocorrelation Function for Owner: {owner_name}')
    
    plt.tight_layout()
    display(plt.gcf())
    plt.close()
    
    # Find significant lags (95% confidence)
    significance_level = 1.96/np.sqrt(len(timeseries))
    
    # Significant lags in ACF (for MA/q order)
    significant_acf = [i for i in range(1, max_lags + 1) if abs(acf_values[i]) > significance_level]
    
    # Significant lags in PACF (for AR/p order)
    significant_pacf = [i for i in range(1, max_lags + 1) if abs(pacf_values[i]) > significance_level]
    
    print(f"Owner: {owner_name}")
    print(f"Significant lags in ACF (suggests MA/q order): {significant_acf}")
    print(f"Significant lags in PACF (suggests AR/p order): {significant_pacf}")
    
    # Check for seasonality (12 months)
    if max_lags >= 12 and len(timeseries) >= 24:
        seasonal_lag = 12
        if seasonal_lag in significant_acf or seasonal_lag in significant_pacf:
            print(f"Potential yearly seasonality detected at lag {seasonal_lag}")
    
    print("-" * 50)
    
    # Suggested order
    p = max(significant_pacf) if significant_pacf else 1
    q = max(significant_acf) if significant_acf else 1
    
    return p, q, acf_values, pacf_values

# Analyze ACF and PACF for each owner with sufficient data
acf_pacf_results = {}

for owner in owners:
    owner_data = df[df['Owner'] == owner].sort_values('Date')
    values = owner_data['Value'].values
    
    # Only analyze if we have enough data points
    if len(values) >= 24:  # Minimum recommended for monthly data (2 years)
        print(f"Analyzing ACF/PACF for Owner: {owner} (Months of data: {len(values)})")
        
        # Check if differencing is needed
        is_stationary, _ = stationarity_results[owner]['is_stationary'], stationarity_results[owner]['p_value']
        
        # If not stationary, difference the series
        if not is_stationary:
            print(f"Series for {owner} is not stationary, applying differencing")
            values_diff = np.diff(values)
            p, q, acf_vals, pacf_vals = analyze_acf_pacf(values_diff, f"{owner} (differenced)")
            d = 1
        else:
            p, q, acf_vals, pacf_vals = analyze_acf_pacf(values, owner)
            d = 0
            
        # For monthly data, we might need higher max_lags to catch seasonality
        if len(values) >= 36:  # If we have at least 3 years of data
            p_seasonal, q_seasonal, _, _ = analyze_acf_pacf(values if is_stationary else values_diff, 
                                                         f"{owner} (seasonal check)", 
                                                         max_lags=24)
            # Use the higher of the two if seasonal analysis found something
            p = max(p, p_seasonal) if p_seasonal > p else p
            q = max(q, q_seasonal) if q_seasonal > q else q
            
        acf_pacf_results[owner] = {
            'p': p,
            'd': d,
            'q': q,
            'acf_values': acf_vals,
            'pacf_values': pacf_vals
        }
        
        print(f"Suggested ARIMA order for {owner}: ({p}, {d}, {q})")
    else:
        print(f"Owner {owner} has only {len(values)} months of data, not enough for robust ACF/PACF analysis.")
        acf_pacf_results[owner] = None

# Train ARIMA models for owners with sufficient data
arima_results = {}

for owner in owners:
    owner_data = df[df['Owner'] == owner].sort_values('Date')
    values = owner_data['Value'].values
    dates = owner_data['Date'].values
    
    # Only attempt ARIMA if we have enough data points (at least 24 months / 2 years)
    if len(values) >= 24 and acf_pacf_results[owner] is not None:
        print(f"Training ARIMA model for Owner: {owner}")
        
        # Get suggested order
        p, d, q = acf_pacf_results[owner]['p'], acf_pacf_results[owner]['d'], acf_pacf_results[owner]['q']
        
        try:
            # Train ARIMA model
            model = ARIMA(values, order=(p, d, q))
            model_fit = model.fit()
            
            # Print model summary
            print(f"ARIMA model summary for Owner: {owner}")
            print(model_fit.summary())
            
            arima_results[owner] = {
                'model': model_fit,
                'order': (p, d, q),
                'values': values,
                'dates': dates,
                'model_type': f"ARIMA({p},{d},{q})"
            }
            
        except Exception as e:
            print(f"Error training ARIMA for {owner}: {str(e)}")
            print("Trying simpler ARIMA(1,1,1) model...")
            
            try:
                # Try with simpler model
                model = ARIMA(values, order=(1, 1, 1))
                model_fit = model.fit()
                
                arima_results[owner] = {
                    'model': model_fit,
                    'order': (1, 1, 1),
                    'values': values,
                    'dates': dates,
                    'model_type': "ARIMA(1,1,1)"
                }
                
            except Exception as e2:
                print(f"Error training simpler ARIMA for {owner}: {str(e2)}")
                arima_results[owner] = None
    else:
        print(f"Owner {owner} has insufficient data for ARIMA modeling.")
        arima_results[owner] = None

# Train linear regression models for all owners
linear_results = {}

for owner in owners:
    owner_data = df[df['Owner'] == owner].sort_values('Date')
    values = owner_data['Value'].values
    dates = owner_data['Date'].values
    
    print(f"Training Linear Regression model for Owner: {owner}")
    
    # For monthly data, convert dates to numeric feature (months since first date)
    first_date = min(dates)
    X = np.array([((d.year - first_date.year) * 12 + d.month - first_date.month) for d in dates]).reshape(-1, 1)
    
    # Fit model
    model = LinearRegression()
    model.fit(X, values)
    
    # Calculate R-squared
    y_pred = model.predict(X)
    ss_total = np.sum((values - np.mean(values))**2)
    ss_residual = np.sum((values - y_pred)**2)
    r_squared = 1 - (ss_residual / ss_total)
    
    print(f"Linear Regression coefficients for {owner}:")
    print(f"Intercept: {model.intercept_:.4f}")
    print(f"Slope (per month): {model.coef_[0]:.4f}")
    print(f"R-squared: {r_squared:.4f}")
    
    linear_results[owner] = {
        'model': model,
        'first_date': first_date,
        'values': values,
        'dates': dates,
        'r_squared': r_squared,
        'model_type': "Linear Regression"
    }

# Generate forecasts for each owner
forecast_months = 12  # Number of months to forecast
forecast_results = {}

for owner in owners:
    print(f"Generating forecast for Owner: {owner}")
    
    # Check if we have a valid ARIMA model
    if arima_results[owner] is not None:
        print(f"Using {arima_results[owner]['model_type']} model for {owner}")
        
        # Get the model and data
        model = arima_results[owner]['model']
        values = arima_results[owner]['values']
        dates = arima_results[owner]['dates']
        
        # Generate forecast
        forecast = model.forecast(steps=forecast_months)
        forecast_conf = model.get_forecast(steps=forecast_months)
        conf_int = forecast_conf.conf_int()
        
        # Generate future dates (monthly)
        last_date = dates[-1]
        future_dates = [last_date + relativedelta(months=i+1) for i in range(forecast_months)]
        
        forecast_results[owner] = {
            'forecast': forecast,
            'conf_int': conf_int,
            'future_dates': future_dates,
            'model_type': arima_results[owner]['model_type']
        }
    else:
        print(f"Using Linear Regression model for {owner}")
        
        # Get the model and data
        model = linear_results[owner]['model']
        first_date = linear_results[owner]['first_date']
        values = linear_results[owner]['values']
        dates = linear_results[owner]['dates']
        
        # Get the last date
        last_date = dates[-1]
        
        # Generate future months (as X values)
        months_since_first = [
            ((last_date.year - first_date.year) * 12 + last_date.month - first_date.month) + i + 1 
            for i in range(forecast_months)
        ]
        future_X = np.array(months_since_first).reshape(-1, 1)
        
        # Generate forecast
        forecast = model.predict(future_X)
        
        # Generate simple confidence intervals
        # (This is a simplification - not statistically rigorous)
        prediction_std = np.std(values - model.predict(
            np.array([((d.year - first_date.year) * 12 + d.month - first_date.month) for d in dates]).reshape(-1, 1)
        ))
        conf_lower = forecast - 1.96 * prediction_std
        conf_upper = forecast + 1.96 * prediction_std
        
        # Create a DataFrame similar to ARIMA's conf_int
        conf_int = pd.DataFrame({
            'lower': conf_lower,
            'upper': conf_upper
        })
        
        # Generate future dates (monthly)
        future_dates = [last_date + relativedelta(months=i+1) for i in range(forecast_months)]
        
        forecast_results[owner] = {
            'forecast': forecast,
            'conf_int': conf_int,
            'future_dates': future_dates,
            'model_type': "Linear Regression"
        }

# Plot forecasts for each owner
for owner in owners:
    # Get owner data
    owner_data = df[df['Owner'] == owner].sort_values('Date')
    dates = owner_data['Date']
    values = owner_data['Value']
    
    # Get forecast data
    forecast = forecast_results[owner]['forecast']
    conf_int = forecast_results[owner]['conf_int']
    future_dates = forecast_results[owner]['future_dates']
    model_type = forecast_results[owner]['model_type']
    
    # Create plot
    plt.figure(figsize=(14, 7))
    
    # Plot historical data
    plt.plot(dates, values, label='Historical Data', marker='o', color='blue')
    
    # Plot forecast
    plt.plot(future_dates, forecast, label=f'Forecast ({model_type})', 
             color='red', marker='x', linestyle='--')
    
    # Plot confidence interval
    if isinstance(conf_int, pd.DataFrame):
        plt.fill_between(future_dates, 
                         conf_int['lower'], 
                         conf_int['upper'], 
                         color='red', alpha=0.2)
    
    # Add labels and title
    plt.title(f'Monthly Forecast for Owner: {owner} using {model_type}')
    plt.xlabel('Date')
    plt.ylabel('Value')
    plt.grid(True)
    plt.legend()
    
    # Add vertical line at the forecast start
    plt.axvline(x=dates.iloc[-1], color='green', linestyle='--', 
                label='Forecast Start')
    
    # Format date axis to show month-year
    plt.gca().xaxis.set_major_formatter(plt.matplotlib.dates.DateFormatter('%b %Y'))
    plt.gcf().autofmt_xdate()
    
    # Display plot
    display(plt.gcf())
    plt.close()

# Create summary report
summary_data = []

for owner in owners:
    # Get original data
    owner_data = df[df['Owner'] == owner]
    
    # Get forecast data
    forecast = forecast_results[owner]['forecast']
    model_type = forecast_results[owner]['model_type']
    future_dates = forecast_results[owner]['future_dates']
    
    # Calculate growth metrics
    last_value = owner_data['Value'].iloc[-1]
    forecast_first = forecast[0]  # First month forecast
    forecast_third = forecast[2] if len(forecast) > 2 else np.nan  # 3-month forecast
    forecast_sixth = forecast[5] if len(forecast) > 5 else np.nan  # 6-month forecast
    forecast_last = forecast[-1]  # 12-month forecast
    
    # Calculate percentage changes
    pct_change_1m = ((forecast_first - last_value) / last_value) * 100 if last_value != 0 else np.inf
    pct_change_3m = ((forecast_third - last_value) / last_value) * 100 if last_value != 0 else np.inf
    pct_change_6m = ((forecast_sixth - last_value) / last_value) * 100 if last_value != 0 else np.inf
    pct_change_12m = ((forecast_last - last_value) / last_value) * 100 if last_value != 0 else np.inf
    
    # Add to summary
    summary_data.append({
        'Owner': owner,
        'Model_Type': model_type,
        'Months_of_Data': len(owner_data),
        'Last_Actual_Value': round(last_value, 2),
        'Forecast_1M': round(forecast_first, 2),
        'Forecast_3M': round(forecast_third, 2) if not np.isnan(forecast_third) else np.nan,
        'Forecast_6M': round(forecast_sixth, 2) if not np.isnan(forecast_sixth) else np.nan,
        'Forecast_12M': round(forecast_last, 2),
        '%_Change_1M': round(pct_change_1m, 2),
        '%_Change_3M': round(pct_change_3m, 2) if not np.isnan(forecast_third) else np.nan,
        '%_Change_6M': round(pct_change_6m, 2) if not np.isnan(forecast_sixth) else np.nan,
        '%_Change_12M': round(pct_change_12m, 2)
    })

# Create DataFrame and display summary
summary_df = pd.DataFrame(summary_data)
print("Forecast Summary Report:")
display(summary_df)

# Create detailed forecast tables for each owner
for owner in owners:
    # Get forecast data
    forecast = forecast_results[owner]['forecast']
    future_dates = forecast_results[owner]['future_dates']
    model_type = forecast_results[owner]['model_type']
    
    # Create DataFrame with forecasts
    forecast_df = pd.DataFrame({
        'Month': [d.strftime('%Y-%m') for d in future_dates],
        'Forecasted_Value': forecast,
        'Model_Type': model_type
    })
    
    # Display
    print(f"Detailed monthly forecast for {owner} using {model_type}:")
    display(forecast_df)

# Optional: Seasonal analysis for owners with sufficient data
for owner in owners:
    owner_data = df[df['Owner'] == owner].sort_values('Date')
    
    # Only analyze if we have enough data (at least 2 years)
    if len(owner_data) >= 24:
        print(f"Seasonal analysis for Owner: {owner}")
        
        # Create a month column
        owner_data['Month'] = owner_data['Date'].dt.month
        
        # Group by month and calculate average
        monthly_avg = owner_data.groupby('Month')['Value'].mean().reset_index()
        monthly_avg['Month_Name'] = monthly_avg['Month'].apply(lambda x: datetime(2000, x, 1).strftime('%b'))
        
        # Plot monthly averages
        plt.figure(figsize=(12, 6))
        plt.bar(monthly_avg['Month_Name'], monthly_avg['Value'], color='skyblue')
        plt.title(f'Monthly Seasonal Pattern for Owner: {owner}')
        plt.xlabel('Month')
        plt.ylabel('Average Value')
        plt.grid(axis='y', linestyle='--', alpha=0.7)
        
        # Display plot
        display(plt.gcf())
        plt.close()
        
        # Identify peak and trough months
        peak_month = monthly_avg.loc[monthly_avg['Value'].idxmax()]
        trough_month = monthly_avg.loc[monthly_avg['Value'].idxmin()]
        
        print(f"Peak month: {peak_month['Month_Name']} (Average: {peak_month['Value']:.2f})")
        print(f"Trough month: {trough_month['Month_Name']} (Average: {trough_month['Value']:.2f})")
        print("-" * 50)
        
        # Display monthly average data
        print("Monthly average values:")
        display(monthly_avg[['Month_Name', 'Value']].sort_values('Month'))

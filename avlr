# Generate initial forecasts for each owner
logger.info(f"Generating {FORECAST_MONTHS}-month initial forecasts for each owner")
initial_forecast_results = {}

# Store model metadata for MLflow tracking
model_metadata = {}

for owner in all_owners:
    logger.info(f"Generating initial forecast for Owner: {owner}")
    print(f"Generating initial forecast for Owner: {owner}")
    
    # Choose the best model
    if PREFER_LINEAR_REGRESSION and len(df[df['Owner'] == owner]) <= MIN_MONTHS_FOR_ARIMA:
        logger.info(f"Preferring Linear Regression for {owner} due to limited data")
        use_arima = False
    elif owner in arima_results and arima_results[owner] is not None:
        # Compare metrics to choose the best model
        arima_metrics = arima_results[owner]['metrics']
        linear_metrics = linear_results[owner]['metrics']
        
        if arima_metrics['rmse'] < linear_metrics['rmse']:
            use_arima = True
        else:
            use_arima = False
    else:
        use_arima = False
    
    # Check if we have a valid ARIMA model and should use it
    if use_arima:
        logger.info(f"Using {arima_results[owner]['model_type']} model for {owner}")
        print(f"Using {arima_results[owner]['model_type']} model for {owner}")
        
        # Get the model and data
        model_fit = arima_results[owner]['model_fit']
        values = arima_results[owner]['values']
        dates = arima_results[owner]['dates']
        model_type = arima_results[owner]['model_type']
        metrics = arima_results[owner]['metrics']
        is_transformed = arima_results[owner].get('transformed', False)
        min_value = arima_results[owner].get('min_value', 0)
        
        # Store model metadata
        model_metadata[owner] = {
            'model_fit': model_fit,
            'model_type': model_type,
            'framework': 'statsmodels.ARIMA',
            'metrics': metrics,
            'params': {
                'order': arima_results[owner]['order']
            }
        }
        
        # Generate forecast
        if is_transformed:
            # Generate forecast on transformed scale
            forecast_transformed = model_fit.forecast(steps=FORECAST_MONTHS)
            
            # Back-transform to original scale
            if min_value > 0:
                forecast = np.exp(forecast_transformed)
            else:
                forecast = np.exp(forecast_transformed) - MIN_VALUE
            
            # Ensure non-negative values
            forecast = np.maximum(forecast, 0)
            
            # Generate confidence intervals on transformed scale
            forecast_conf = model_fit.get_forecast(steps=FORECAST_MONTHS)
            conf_int_transformed = forecast_conf.conf_int(alpha=(1 - CONFIDENCE_LEVEL/100))
            
            # Back-transform confidence intervals
            if min_value > 0:
                conf_lower = np.exp(conf_int_transformed.iloc[:, 0])
                conf_upper = np.exp(conf_int_transformed.iloc[:, 1])
            else:
                conf_lower = np.exp(conf_int_transformed.iloc[:, 0]) - MIN_VALUE
                conf_upper = np.exp(conf_int_transformed.iloc[:, 1]) - MIN_VALUE
            
            # Ensure lower bound is non-negative
            conf_lower = np.maximum(conf_lower, 0)
            
            # Create a DataFrame for confidence intervals
            conf_int = pd.DataFrame({
                'lower': conf_lower,
                'upper': conf_upper
            })
        else:
            # Generate forecast directly
            forecast = model_fit.forecast(steps=FORECAST_MONTHS)
            
            # Ensure non-negative values if required
            if ENFORCE_NON_NEGATIVE:
                forecast = np.maximum(forecast, 0)
            
            # Generate confidence intervals
            forecast_conf = model_fit.get_forecast(steps=FORECAST_MONTHS)
            conf_int = forecast_conf.conf_int(alpha=(1 - CONFIDENCE_LEVEL/100))
            
            # Ensure lower bound is non-negative if required
            if ENFORCE_NON_NEGATIVE:
                conf_int.iloc[:, 0] = np.maximum(conf_int.iloc[:, 0], 0)
        
        # Generate future dates (monthly)
        last_date = to_python_datetime(dates[-1])
        future_dates = [last_date + relativedelta(months=i+1) for i in range(FORECAST_MONTHS)]
        
        # Store forecast results
        initial_forecast_results[owner] = {
            'forecast': forecast,
            'conf_int': conf_int,
            'future_dates': future_dates,
            'model_type': model_type
        }
    else:
        logger.info(f"Using Linear Regression model for {owner}")
        print(f"Using Linear Regression model for {owner}")
        
        # Get the model and data
        model_fit = linear_results[owner]['model_fit']
        first_date = linear_results[owner]['first_date']
        values = linear_results[owner]['values']
        dates = linear_results[owner]['dates']
        metrics = linear_results[owner]['metrics']
        
        # Store model metadata
        model_metadata[owner] = {
            'model_fit': model_fit,
            'model_type': 'Linear Regression',
            'framework': 'sklearn.LinearRegression',
            'metrics': metrics,
            'params': {
                'fit_intercept': True,
                'constrained': CONSTRAINED_LINEAR and ENFORCE_NON_NEGATIVE
            }
        }
        
        # Get the last date
        last_date = to_python_datetime(dates[-1])
        
        # Generate future months (as X values)
        months_since_first = [
            ((last_date.year - to_python_datetime(first_date).year) * 12 + 
             last_date.month - to_python_datetime(first_date).month) + i + 1 
            for i in range(FORECAST_MONTHS)
        ]
        future_X = np.array(months_since_first).reshape(-1, 1)
        
        # Generate forecast
        forecast = model_fit.predict(future_X)
        
        # Ensure non-negative values if required
        if ENFORCE_NON_NEGATIVE:
            forecast = np.maximum(forecast, 0)
        
        # Generate simple confidence intervals
        prediction_std = np.std(values - linear_results[owner]['in_sample_pred'])
        conf_lower = forecast - Z_VALUE * prediction_std
        conf_upper = forecast + Z_VALUE * prediction_std
        
        # Ensure lower bound is non-negative if required
        if ENFORCE_NON_NEGATIVE:
            conf_lower = np.maximum(conf_lower, 0)
        
        # Create a DataFrame similar to ARIMA's conf_int
        conf_int = pd.DataFrame({
            'lower': conf_lower,
            'upper': conf_upper
        })
        
        # Generate future dates (monthly)
        future_dates = [last_date + relativedelta(months=i+1) for i in range(FORECAST_MONTHS)]
        
        # Store forecast results
        initial_forecast_results[owner] = {
            'forecast': forecast,
            'conf_int': conf_int,
            'future_dates': future_dates,
            'model_type': "Linear Regression"
        }

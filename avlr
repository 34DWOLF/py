# Import required libraries
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.stattools import adfuller, acf, pacf
from statsmodels.tsa.arima.model import ARIMA
from statsmodels.graphics.tsaplots import plot_acf, plot_pacf
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error, mean_absolute_error, r2_score, mean_absolute_percentage_error
from datetime import datetime, timedelta
import warnings
from dateutil.relativedelta import relativedelta
import logging

# ====================================================
# PARAMETER SECTION - Modify these values as needed
# ====================================================
# Minimum number of months required for ARIMA modeling
MIN_MONTHS_FOR_ARIMA = 6  # Set to allow ARIMA with 6 months of data

# Minimum number of months required for stationarity testing
MIN_MONTHS_FOR_STATIONARITY = 6  # Minimum needed

# Number of months to forecast
FORECAST_MONTHS = 3  # Forecast half the length of available data

# Maximum lags to consider for ACF/PACF analysis
MAX_LAGS_DEFAULT = 2  # Limited with 6 data points
MAX_LAGS_SEASONAL = 6  # Cannot detect yearly seasonality

# Confidence interval level (%)
CONFIDENCE_LEVEL = 90  # 90% confidence as requested
Z_VALUE = 1.645  # Corresponds to 90% confidence

# Non-negativity constraint
ENFORCE_NON_NEGATIVE = True  # Flag to ensure forecasts don't go below zero

# Reconciliation method
RECONCILIATION_METHOD = "proportional"  

# Plot settings
FIGSIZE_TIMESERIES = (14, 7)
FIGSIZE_ACF_PACF = (12, 8)
# ====================================================

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger('forecast_model')

# Suppress warnings for cleaner output
warnings.filterwarnings("ignore")

# Set plot style for better visualizations
plt.style.use('seaborn-whitegrid')

# Helper function to convert numpy.datetime64 to Python datetime
def to_python_datetime(dt):
    if isinstance(dt, np.datetime64):
        return pd.Timestamp(dt).to_pydatetime()
    return dt

# Function to calculate evaluation metrics
def calculate_metrics(y_true, y_pred):
    """Calculate various evaluation metrics using sklearn"""
    metrics = {}
    
    # R-squared (coefficient of determination)
    metrics['r2'] = r2_score(y_true, y_pred)
    
    # Mean Squared Error
    metrics['mse'] = mean_squared_error(y_true, y_pred)
    
    # Root Mean Squared Error
    metrics['rmse'] = np.sqrt(metrics['mse'])
    
    # Mean Absolute Error
    metrics['mae'] = mean_absolute_error(y_true, y_pred)
    
    # Mean Absolute Percentage Error
    # Handle case where y_true contains zeros
    if np.any(y_true == 0):
        # Calculate MAPE only for non-zero values
        non_zero_indices = y_true != 0
        if np.any(non_zero_indices):
            metrics['mape'] = mean_absolute_percentage_error(
                y_true[non_zero_indices], 
                y_pred[non_zero_indices]
            ) * 100  # Convert to percentage
        else:
            metrics['mape'] = np.nan
    else:
        metrics['mape'] = mean_absolute_percentage_error(y_true, y_pred) * 100  # Convert to percentage
    
    return metrics

# Train ARIMA models for owners with sufficient data
logger.info("Training ARIMA models for eligible owners")
arima_results = {}

for owner in all_owners:
    owner_data = df[df['Owner'] == owner].sort_values('Date')
    values = owner_data['Value'].values
    dates = owner_data['Date'].values
    
    # Only attempt ARIMA if we have enough data points
    if len(values) >= MIN_MONTHS_FOR_ARIMA:
        logger.info(f"Training ARIMA model for Owner: {owner}")
        print(f"Training ARIMA model for Owner: {owner}")
        
        # Get suggested order from previous analysis
        if owner in acf_pacf_results and acf_pacf_results[owner] is not None:
            p, d, q = acf_pacf_results[owner]['p'], acf_pacf_results[owner]['d'], acf_pacf_results[owner]['q']
        else:
            # Simple default if not available
            p, d, q = 1, 0, 0
        
        try:
            # Train ARIMA model
            model = ARIMA(values, order=(p, d, q))
            model_fit = model.fit()
            
            # Calculate in-sample predictions
            if d > 0:
                # For differenced models
                in_sample_pred = model_fit.predict(start=d, end=len(values)-1)
                # Ensure lengths match for metric calculation
                actuals = values[d:]
            else:
                in_sample_pred = model_fit.predict(start=0, end=len(values)-1)
                actuals = values
            
            # Ensure in-sample predictions are non-negative if required
            if ENFORCE_NON_NEGATIVE:
                in_sample_pred = np.maximum(in_sample_pred, 0)
            
            # Calculate metrics
            metrics = calculate_metrics(actuals, in_sample_pred)
            
            # Print model summary
            print(f"ARIMA model summary for Owner: {owner}")
            print(model_fit.summary())
            
            # Print metrics
            print(f"ARIMA model metrics for {owner}:")
            for metric_name, metric_value in metrics.items():
                print(f"  {metric_name.upper()}: {metric_value:.4f}")
            
            # Store ARIMA results
            arima_results[owner] = {
                'model_fit': model_fit,
                'order': (p, d, q),
                'values': values,
                'dates': dates,
                'model_type': f"ARIMA({p},{d},{q})",
                'in_sample_pred': in_sample_pred,
                'metrics': metrics
            }
            
            logger.info(f"Successfully trained ARIMA({p},{d},{q}) for {owner}")
            
        except Exception as e:
            logger.warning(f"Error training ARIMA for {owner}: {str(e)}")
            print(f"Error training ARIMA for {owner}: {str(e)}")
            arima_results[owner] = None
    else:
        logger.info(f"Owner {owner} has insufficient data for ARIMA modeling.")
        print(f"Owner {owner} has insufficient data for ARIMA modeling.")
        arima_results[owner] = None

# Train linear regression models for all owners
logger.info("Training Linear Regression models for all owners")
linear_results = {}

for owner in all_owners:
    owner_data = df[df['Owner'] == owner].sort_values('Date')
    values = owner_data['Value'].values
    dates = owner_data['Date'].to_list()  # Convert to Python datetime objects
    
    logger.info(f"Training Linear Regression model for Owner: {owner}")
    print(f"Training Linear Regression model for Owner: {owner}")
    
    # For monthly data, convert dates to numeric feature (months since first date)
    first_date = min(dates)
    # Properly calculate months since first date
    X = np.array([
        (to_python_datetime(d).year - to_python_datetime(first_date).year) * 12 + 
        to_python_datetime(d).month - to_python_datetime(first_date).month 
        for d in dates
    ]).reshape(-1, 1)
    
    # Standard linear regression
    model = LinearRegression()
    model.fit(X, values)
    
    # Generate in-sample predictions
    in_sample_pred = model.predict(X)
    
    # Ensure in-sample predictions are non-negative if required
    if ENFORCE_NON_NEGATIVE:
        in_sample_pred = np.maximum(in_sample_pred, 0)
    
    # Calculate metrics
    metrics = calculate_metrics(values, in_sample_pred)
    
    # Print coefficient details
    print(f"Linear Regression coefficients for {owner}:")
    print(f"  Intercept: {model.intercept_:.4f}")
    print(f"  Slope (per month): {model.coef_[0]:.4f}")
    
    # Print metrics
    print(f"Linear Regression model metrics for {owner}:")
    for metric_name, metric_value in metrics.items():
        print(f"  {metric_name.upper()}: {metric_value:.4f}")
    
    # Store linear regression results
    linear_results[owner] = {
        'model_fit': model,
        'first_date': first_date,
        'values': values,
        'dates': dates,
        'in_sample_pred': in_sample_pred,
        'metrics': metrics,
        'model_type': "Linear Regression"
    }
    logger.info(f"Successfully trained Linear Regression for {owner}, R-squared: {metrics['r2']:.4f}")

# Generate initial forecasts for each owner
logger.info(f"Generating {FORECAST_MONTHS}-month initial forecasts for each owner")
initial_forecast_results = {}

# Store model metadata for MLflow tracking
model_metadata = {}

for owner in all_owners:
    logger.info(f"Generating initial forecast for Owner: {owner}")
    print(f"Generating initial forecast for Owner: {owner}")
    
    # Compare metrics to choose the best model
    if owner in arima_results and arima_results[owner] is not None:
        arima_metrics = arima_results[owner]['metrics']
        linear_metrics = linear_results[owner]['metrics']
        
        if arima_metrics['rmse'] < linear_metrics['rmse']:
            use_arima = True
        else:
            use_arima = False
    else:
        use_arima = False
    
    # Check if we have a valid ARIMA model and should use it
    if use_arima:
        logger.info(f"Using {arima_results[owner]['model_type']} model for {owner}")
        print(f"Using {arima_results[owner]['model_type']} model for {owner}")
        
        # Get the model and data
        model_fit = arima_results[owner]['model_fit']
        values = arima_results[owner]['values']
        dates = arima_results[owner]['dates']
        model_type = arima_results[owner]['model_type']
        metrics = arima_results[owner]['metrics']
        
        # Store model metadata
        model_metadata[owner] = {
            'model_fit': model_fit,
            'model_type': model_type,
            'framework': 'statsmodels.ARIMA',
            'metrics': metrics,
            'params': {
                'order': arima_results[owner]['order']
            }
        }
        
        # Generate forecast
        forecast = model_fit.forecast(steps=FORECAST_MONTHS)
        
        # Ensure forecasts are non-negative if required
        if ENFORCE_NON_NEGATIVE:
            forecast = np.maximum(forecast, 0)
        
        # Generate confidence intervals
        forecast_conf = model_fit.get_forecast(steps=FORECAST_MONTHS)
        conf_int = forecast_conf.conf_int(alpha=(1 - CONFIDENCE_LEVEL/100))
        
        # Ensure confidence interval lower bounds are non-negative if required
        if ENFORCE_NON_NEGATIVE:
            conf_int.iloc[:, 0] = np.maximum(conf_int.iloc[:, 0], 0)
        
        # Generate future dates (monthly)
        last_date = to_python_datetime(dates[-1])
        future_dates = [last_date + relativedelta(months=i+1) for i in range(FORECAST_MONTHS)]
        
        # Store forecast results
        initial_forecast_results[owner] = {
            'forecast': forecast,
            'conf_int': conf_int,
            'future_dates': future_dates,
            'model_type': model_type
        }
    else:
        logger.info(f"Using Linear Regression model for {owner}")
        print(f"Using Linear Regression model for {owner}")
        
        # Get the model and data
        model_fit = linear_results[owner]['model_fit']
        first_date = linear_results[owner]['first_date']
        values = linear_results[owner]['values']
        dates = linear_results[owner]['dates']
        metrics = linear_results[owner]['metrics']
        
        # Store model metadata
        model_metadata[owner] = {
            'model_fit': model_fit,
            'model_type': 'Linear Regression',
            'framework': 'sklearn.LinearRegression',
            'metrics': metrics,
            'params': {
                'fit_intercept': True
            }
        }
        
        # Get the last date
        last_date = to_python_datetime(dates[-1])
        
        # Generate future months (as X values)
        months_since_first = [
            ((last_date.year - to_python_datetime(first_date).year) * 12 + 
             last_date.month - to_python_datetime(first_date).month) + i + 1 
            for i in range(FORECAST_MONTHS)
        ]
        future_X = np.array(months_since_first).reshape(-1, 1)
        
        # Generate forecast
        forecast = model_fit.predict(future_X)
        
        # Ensure forecasts are non-negative if required
        if ENFORCE_NON_NEGATIVE:
            forecast = np.maximum(forecast, 0)
        
        # Generate simple confidence intervals
        prediction_std = np.std(values - linear_results[owner]['in_sample_pred'])
        conf_lower = forecast - Z_VALUE * prediction_std
        conf_upper = forecast + Z_VALUE * prediction_std
        
        # Ensure confidence interval lower bounds are non-negative if required
        if ENFORCE_NON_NEGATIVE:
            conf_lower = np.maximum(conf_lower, 0)
        
        # Create a DataFrame similar to ARIMA's conf_int
        conf_int = pd.DataFrame({
            'lower': conf_lower,
            'upper': conf_upper
        })
        
        # Generate future dates (monthly)
        future_dates = [last_date + relativedelta(months=i+1) for i in range(FORECAST_MONTHS)]
        
        # Store forecast results
        initial_forecast_results[owner] = {
            'forecast': forecast,
            'conf_int': conf_int,
            'future_dates': future_dates,
            'model_type': "Linear Regression"
        }

# Reconcile forecasts if 'Total' is present
if is_total_present:
    logger.info("Reconciling forecasts to ensure consistency with 'Total'")
    print("\nReconciling forecasts to ensure consistency with 'Total'...")
    
    # Get total forecast
    total_forecast = initial_forecast_results["Total"]["forecast"]
    
    # Get sum of individual forecasts
    individual_forecasts = np.zeros(FORECAST_MONTHS)
    for owner in other_owners:
        individual_forecasts += initial_forecast_results[owner]["forecast"]
    
    # Calculate discrepancy
    discrepancy = total_forecast - individual_forecasts
    print(f"Discrepancy between 'Total' and sum of individuals: {discrepancy}")
    
    # Reconciliation methods
    reconciled_forecast_results = {}
    reconciled_forecast_results["Total"] = initial_forecast_results["Total"]  # Keep original Total
    
    if RECONCILIATION_METHOD == "proportional":
        # Proportional reconciliation
        logger.info("Using proportional reconciliation method")
        print("Using proportional reconciliation method")
        
        for month in range(FORECAST_MONTHS):
            # Skip reconciliation if sum is close to zero to avoid division by zero
            if abs(individual_forecasts[month]) < 1e-10:
                for owner in other_owners:
                    if "reconciled_forecast" not in reconciled_forecast_results.get(owner, {}):
                        reconciled_forecast_results[owner] = {
                            "reconciled_forecast": initial_forecast_results[owner]["forecast"].copy(),
                            "future_dates": initial_forecast_results[owner]["future_dates"],
                            "model_type": initial_forecast_results[owner]["model_type"],
                            "initial_forecast": initial_forecast_results[owner]["forecast"].copy(),
                            "conf_int": initial_forecast_results[owner]["conf_int"]
                        }
                continue
            
            # Calculate proportional adjustment for each owner
            for owner in other_owners:
                if "reconciled_forecast" not in reconciled_forecast_results.get(owner, {}):
                    reconciled_forecast_results[owner] = {
                        "reconciled_forecast": initial_forecast_results[owner]["forecast"].copy(),
                        "future_dates": initial_forecast_results[owner]["future_dates"],
                        "model_type": initial_forecast_results[owner]["model_type"],
                        "initial_forecast": initial_forecast_results[owner]["forecast"].copy(),
                        "conf_int": initial_forecast_results[owner]["conf_int"]
                    }
                
                # Proportional adjustment
                owner_forecast = initial_forecast_results[owner]["forecast"][month]
                proportion = owner_forecast / individual_forecasts[month] if individual_forecasts[month] != 0 else 0
                adjustment = discrepancy[month] * proportion
                reconciled_forecast_results[owner]["reconciled_forecast"][month] += adjustment
                
                # Ensure non-negative values after reconciliation if required
                if ENFORCE_NON_NEGATIVE:
                    reconciled_forecast_results[owner]["reconciled_forecast"][month] = max(
                        reconciled_forecast_results[owner]["reconciled_forecast"][month], 0
                    )
    
    elif RECONCILIATION_METHOD == "weight_forecast":
        # Weight by forecast uncertainty (using confidence interval width)
        logger.info("Using uncertainty-weighted reconciliation method")
        print("Using uncertainty-weighted reconciliation method")
        
        for month in range(FORECAST_MONTHS):
            # Calculate weights based on forecast uncertainty
            weights = {}
            total_weight = 0
            
            for owner in other_owners:
                conf_int = initial_forecast_results[owner]["conf_int"]
                uncertainty = conf_int.iloc[month, 1] - conf_int.iloc[month, 0]  # Upper - Lower
                
                # Inverse of uncertainty as weight (more certain forecasts get higher weight)
                weight = 1.0 / uncertainty if uncertainty > 0 else 1.0
                weights[owner] = weight
                total_weight += weight
            
            # Normalize weights
            for owner in weights:
                weights[owner] /= total_weight
            
            # Apply weighted adjustments
            for owner in other_owners:
                if "reconciled_forecast" not in reconciled_forecast_results.get(owner, {}):
                    reconciled_forecast_results[owner] = {
                        "reconciled_forecast": initial_forecast_results[owner]["forecast"].copy(),
                        "future_dates": initial_forecast_results[owner]["future_dates"],
                        "model_type": initial_forecast_results[owner]["model_type"],
                        "initial_forecast": initial_forecast_results[owner]["forecast"].copy(),
                        "conf_int": initial_forecast_results[owner]["conf_int"]
                    }
                
                # Weighted adjustment
                adjustment = discrepancy[month] * weights[owner]
                reconciled_forecast_results[owner]["reconciled_forecast"][month] += adjustment
                
                # Ensure non-negative values after reconciliation if required
                if ENFORCE_NON_NEGATIVE:
                    reconciled_forecast_results[owner]["reconciled_forecast"][month] = max(
                        reconciled_forecast_results[owner]["reconciled_forecast"][month], 0
                    )
    
    elif RECONCILIATION_METHOD == "weight_history":
        # Weight by historical share
        logger.info("Using historical share-weighted reconciliation method")
        print("Using historical share-weighted reconciliation method")
        
        # Calculate historical share for each owner
        total_data = df[df['Owner'] == "Total"].sort_values('Date')
        historical_shares = {}
        
        for owner in other_owners:
            owner_data = df[df['Owner'] == owner].sort_values('Date')
            # Merge on date to ensure alignment
            merged_data = pd.merge(owner_data, total_data, on='Date', suffixes=('_owner', '_total'))
            # Calculate historical share
            merged_data['share'] = merged_data['Value_owner'] / merged_data['Value_total']
            # Use average share over all available data
            avg_share = merged_data['share'].mean()
            historical_shares[owner] = avg_share
        
        # Normalize shares to sum to 1
        share_sum = sum(historical_shares.values())
        for owner in historical_shares:
            historical_shares[owner] /= share_sum
        
        # Apply weighted adjustments
        for owner in other_owners:
            if "reconciled_forecast" not in reconciled_forecast_results.get(owner, {}):
                reconciled_forecast_results[owner] = {
                    "reconciled_forecast": initial_forecast_results[owner]["forecast"].copy(),
                    "future_dates": initial_forecast_results[owner]["future_dates"],
                    "model_type": initial_forecast_results[owner]["model_type"],
                    "initial_forecast": initial_forecast_results[owner]["forecast"].copy(),
                    "conf_int": initial_forecast_results[owner]["conf_int"]
                }
            
            # Apply historical share-based adjustment for each month
            for month in range(FORECAST_MONTHS):
                adjustment = discrepancy[month] * historical_shares[owner]
                reconciled_forecast_results[owner]["reconciled_forecast"][month] += adjustment
                
                # Ensure non-negative values after reconciliation if required
                if ENFORCE_NON_NEGATIVE:
                    reconciled_forecast_results[owner]["reconciled_forecast"][month] = max(
                        reconciled_forecast_results[owner]["reconciled_forecast"][month], 0
                    )
    
    else:
        logger.warning(f"Unknown reconciliation method: {RECONCILIATION_METHOD}. Using initial forecasts.")
        print(f"Unknown reconciliation method: {RECONCILIATION_METHOD}. Using initial forecasts.")
        reconciled_forecast_results = initial_forecast_results
    
    # Verify reconciliation
    reconciled_sum = np.zeros(FORECAST_MONTHS)
    for owner in other_owners:
        reconciled_sum += reconciled_forecast_results[owner]["reconciled_forecast"]
    
    # Display reconciliation results
    reconciliation_error = total_forecast - reconciled_sum
    print("\nReconciliation verification:")
    print(f"Total forecast: {total_forecast}")
    print(f"Sum of reconciled individual forecasts: {reconciled_sum}")
    print(f"Remaining discrepancy: {reconciliation_error}")
    print(f"Max absolute error: {np.max(np.abs(reconciliation_error))}")
    
    # Assign reconciled forecasts to final forecast results
    forecast_results = {}
    for owner in all_owners:
        if owner == "Total":
            forecast_results[owner] = initial_forecast_results[owner]
        else:
            forecast_results[owner] = {
                'forecast': reconciled_forecast_results[owner]["reconciled_forecast"],
                'initial_forecast': initial_forecast_results[owner]["forecast"],
                'conf_int': initial_forecast_results[owner]["conf_int"],
                'future_dates': initial_forecast_results[owner]["future_dates"],
                'model_type': initial_forecast_results[owner]["model_type"]
            }
else:
    # If no "Total" owner, use initial forecasts
    forecast_results = initial_forecast_results
